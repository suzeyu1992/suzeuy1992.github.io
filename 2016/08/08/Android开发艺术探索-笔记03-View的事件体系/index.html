<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="suzeyu skyszy`blog">
    <meta name="keyword"  content="suzeyu skyszy`blog">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          《Android 开发艺术探索》 03-View的事件体系 - 筑梦 suzeyu`苏泽钰
        
    </title>

    <link rel="canonical" href="http://szysky.com/2016/08/08/Android开发艺术探索-笔记03-View的事件体系/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/hux-blog.min.css">


    <!-- Pygments Github CSS -->
    
<link rel="stylesheet" href="/css/syntax.css">


    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Szy&#39;sky Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">

                 


                      <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','uaGE1nqtyiBMes6-h6b9','2.0.0');
</script>

                    




                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://szysky.com/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
    .h1_nav{font-size: 13px; padding-left:0%; color: #ff0000;}
    .h2_nav{font-size: 12px;padding-left: 4%;color: #ff0000; }
    .h3_nav{font-size: 11px;padding-left: 12%;}
    .h4_nav{font-size: 10px;padding-left: 18%;}
    .h5_nav{font-size: 9px;padding-left: 24%;}
    .h6_nav{font-size: 8px;padding-left: 30%;}


</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#android" title="android">android</a>
                        
                          <a class="tag" href="/tags/#笔记" title="笔记">笔记</a>
                        
                    </div>
                    <h1>《Android 开发艺术探索》 03-View的事件体系</h1>
                    <h2 class="subheading">抄书系列</h2>
                    <span class="meta">
                        Posted by Suzeyu on
                        2016-08-08
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <span id="more"></span>

<blockquote>
<p>Anroid中的事件是怎样进行的</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/suzeyu1992/Notes_AndroidDevSeek">blog相关代码</a></p>
<h2 id="View的基础知识"><a href="#View的基础知识" class="headerlink" title="View的基础知识"></a>View的基础知识</h2><h3 id="View的位置参数"><a href="#View的位置参数" class="headerlink" title="View的位置参数"></a>View的位置参数</h3><p>一个<code>View</code>的位置主要由四个顶点构成, 或者可以就是两个点就可以确定. 分别为<strong>左上点</strong>,<strong>右下角</strong>每个点都对应x,y两个属性. 因为默认都是矩形, 所以两个点就可以确定. </p>
<p>一个<code>View</code>的大小可以利用四个属性可知. 分别对应<code>getLeft()</code>,<code>getRight()</code>,<code>getTop()</code>,<code>getBottom</code>系统提供的函数.</p>
<ul>
<li>一个控件的宽: getRight() - getLeft()</li>
<li>一个控件的高: getTop() - getBottom()</li>
</ul>
<p><strong>在Android3.0中, View增加了几个属性:<code>x</code> , <code>y</code>, <code>translationX</code>, <code>translationY</code></strong></p>
<ul>
<li><code>x</code> , <code>y</code>: 表示View的左上角坐标点(最终坐标点).</li>
<li><code>translationX</code>, <code>translationY</code>: 表示View的左上点相对于父容器的偏移量(默认是0).</li>
</ul>
<p>而这些参数的换算关系为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = left + translationX;</span><br><span class="line">y = top + translationY;</span><br></pre></td></tr></table></figure>


<h3 id="MotionEvent和TouchSlop"><a href="#MotionEvent和TouchSlop" class="headerlink" title="MotionEvent和TouchSlop"></a>MotionEvent和TouchSlop</h3><p><strong>MotionEvent是指手指在接触屏幕之后产生的一系列事件</strong></p>
<p>最常见事件类型是<code>ACTION_DOWN</code>,<code>ACTION_MOVE</code>,<code>ACTION_UP</code></p>
<p>一次事件可以有不同的<strong>持续时间</strong>, 和不同的<strong>事件类型</strong>. 例如</p>
<ul>
<li>按下抬起 : DOWN –&gt; UP</li>
<li>按下移动抬起 : DOWN -&gt; MOVE -&gt; MOVE -&gt; … -&gt;UP</li>
<li>….</li>
</ul>
<p>而在移动时可以根据<code>MotionEvent</code>提供的参数获对应的xy取值.</p>
<p>*<code>getX/getY</code>: 返回相对于当前View左上角的x,y坐标.<br><code>getRawX/getRawY</code>: 返回的是针对整个屏幕的左上角的x,y坐标.</p>
<p><strong>TouchSlop是系统可以识别的最小滑动距离单位</strong></p>
<p>只有手指两次滑动大于这个<code>TouchSlop</code>,系统才认为是滑动.</p>
<p><code>ViewConfiguration.get(getContent).getSealedTouchSlop()</code>可以获得这个系统值默认<strong>8dp</strong>.</p>
<p>用途: 在自定义的时候, 可以参考系统的默认值, 来作为实际的滑动定义.</p>
<h3 id="VelocityTracker-GestureDetector-和Scroller"><a href="#VelocityTracker-GestureDetector-和Scroller" class="headerlink" title="VelocityTracker GestureDetector 和Scroller"></a>VelocityTracker GestureDetector 和Scroller</h3><p><strong>VelocityTracker 速度追踪</strong></p>
<blockquote>
<p>用于追踪手指在滑动过程中的速度,包括水平和数值方向的速度</p>
</blockquote>
<p>使用方式: 在View的OnTouchEvent方法中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得速度追踪对象</span></span><br><span class="line">VelocityTracker velocity = VelocityTracker.obtain();</span><br><span class="line">velocity.addMovement(event);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算速度 并获取计算值</span></span><br><span class="line">velocity.computeCurrentVelocity(<span class="number">1000</span>); <span class="comment">//设定一个时间间隔值</span></span><br><span class="line"><span class="keyword">float</span> xVelocity = velocity.getXVelocity();</span><br><span class="line"><span class="keyword">float</span> yVelocity = velocity.getYVelocity();</span><br></pre></td></tr></table></figure>

<p>必须要先计算并设定计算速度的时间单元值,才可以获得速率.</p>
<p>公式: <code>速度 = (终点位置 - 起点位置) / 时间间隔值</code></p>
<p>可以看到, 计算的速度是根据我们自己添加的时间间隔值计算的. 并且速度可以为负值,如果向左滑动.</p>
<p>当不需要的时候, 调用<code>clear()</code>重置并回收内存.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">velocity.clear();</span><br><span class="line">velocity.recycle();</span><br></pre></td></tr></table></figure>

<p><strong>GestureDetector 手势检测</strong></p>
<blockquote>
<p>用于辅助检测用户的单击, 滑动, 长按, 双击等行为. </p>
</blockquote>
<p>使用如下</p>
<p>创建<code>GestureDetector</code>对象并实现<code>OnGestureDetector</code>接口.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GestureDetector mGestureDetector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 解决长按屏幕后无法拖动的现象</span></span><br><span class="line">mGestureDetector.setIsLongpressEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后接管目标View的<code>onTouchEvent()</code>方法. 在<code>onTouchEvent()</code>方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> consume = mGestureDetector.onTouchEvent(event);</span><br><span class="line"><span class="keyword">return</span> consume;</span><br></pre></td></tr></table></figure>

<p>然后根据需求可以选择性的实现<code>OnGestureListener</code>和<code>OnDoubleTapListener</code>接口</p>
<p>接口的方法说明:</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>所属接口</th>
</tr>
</thead>
<tbody><tr>
<td><code>onDown</code></td>
<td>按下</td>
<td><code>OnGestureListener</code></td>
</tr>
<tr>
<td><code>onShowPress</code></td>
<td>按下 但是未松开或者拖动.强调状态</td>
<td><code>OnGestureListener</code></td>
</tr>
<tr>
<td><code>onSingleTapUp</code></td>
<td>抬起 表示单击行为, 双击中也会触发</td>
<td><code>OnGestureListener</code></td>
</tr>
<tr>
<td><code>onScroll</code></td>
<td>按下并拖动 拖动行为</td>
<td><code>OnGestureListener</code></td>
</tr>
<tr>
<td><code>onLongPress</code></td>
<td>长按</td>
<td><code>OnGestureListener</code></td>
</tr>
<tr>
<td><code>onFling</code></td>
<td>按下屏幕病快速滑动后松开</td>
<td><code>OnGestureListener</code></td>
</tr>
<tr>
<td><code>onDoubleTap</code></td>
<td>双击,两次连续单击组成, 与onSingleTapConfirmed无法共存</td>
<td><code>OnDoubleTapListener</code></td>
</tr>
<tr>
<td><code>onSingleTapConfirmed</code></td>
<td>严格意义上的单击 双击中的单击无法触发</td>
<td><code>OnDoubleTapListener</code></td>
</tr>
<tr>
<td><code>onDoubleTapEvent</code></td>
<td>表示发生了行为</td>
<td><code>OnDoubleTapListener</code></td>
</tr>
</tbody></table>
<p>实际开发中:根据喜好来使用. 即使不使用<code>GestureDetector</code>辅助手势检测类,一样可以实现.</p>
<p>建议: 如果要监听双击这种行为就是用此类.</p>
<p><strong>Scroller 弹性滑动对象</strong></p>
<blockquote>
<p>用于实现View的弹性滑动.</p>
</blockquote>
<p>在开发中, 当需要把View从一个点移动到另一个点的时候. 如果使用<code>scrollTo/scrollBy</code>进行滑动时, 都是瞬间完成. 没有过度动画, 给用户感觉很生硬. 使用<code>Scroller</code> 可以实现有过渡的滑动.Scroller本身无法让View弹性滑动, 需要和View的<code>computerScroll</code>进行配合使用.</p>
<p>下面会说到</p>
<h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><p>实现滑动的方式有三种:</p>
<ul>
<li>通过View本身的<code>scrollTo/scrollBy</code>方法实现滑动</li>
<li>通过动画给View施加平移效果来实现动画</li>
<li>通过改变View的<code>LayoutParams</code>使View重新布局实现滑动</li>
</ul>
<h3 id="scrollTo-scrollBy"><a href="#scrollTo-scrollBy" class="headerlink" title="scrollTo/scrollBy"></a>scrollTo/scrollBy</h3><p>首先要明确一点: <strong>这两个方法只能改变View的内容位置,而不能改变View本身在布局中的位置</strong></p>
<p>而且方法中都是以像素值来进行移动的. </p>
<ul>
<li>scrollTo: 针对当前View的绝对位置进行移动.</li>
<li>scrollBy: 根据当前View的内容值进行相对位置移动. </li>
</ul>
<p>看一下<code>scrollBy</code>的源码调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实本质上<code>scrollBy</code>调用了<code>scrollTo</code>方法</p>
<p>而<code>mScrollX/mScrollY</code>是什么? 这个就是当前View的内容 与这个View实际布局位置(原始位置)的差值.<br>而当前View内容这个东西就是让用户看到的效果发生改变. 但是如果这个View可以被点击. 那么能触发点击的位置是View的<strong>实际所在布局位置</strong>. 而不是View的内容显示的位置.</p>
<h3 id="使用动画"><a href="#使用动画" class="headerlink" title="使用动画"></a>使用动画</h3><blockquote>
<p>使用动画来对View进行移动,主要就是操作View的<strong>translationX/translationY</strong>属性</p>
</blockquote>
<p>可以使用普通动画和属性动画. </p>
<p>普通动画是对View进行影像的移动. 可以通过设置<code>fillAfter=true</code>,来让影像在动画结束时候保留最终结果.而不是还原到起始位置.</p>
<p>而属性动画会对真实位置也进行改变. </p>
<p><code>ObjectAnimator.ofFloat(tagerView,&quot;translationX&quot;,0,100).setDuration(100).start()</code></p>
<h3 id="改变布局参数"><a href="#改变布局参数" class="headerlink" title="改变布局参数"></a>改变布局参数</h3><p>这个比较简单, 获得View的<code>LayoutParams</code>参数.进行修改,改好之后再赋值回去.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MarginLayoutParams params = (MarginLayoutParams)mTextView.getLayoutParams();</span><br><span class="line">params.width += <span class="number">100</span>;</span><br><span class="line">params.leftMargin += <span class="number">100</span>;</span><br><span class="line">mTextView.requestLayout();</span><br><span class="line"><span class="comment">//或者mTextview.setLayoutParams(params);</span></span><br></pre></td></tr></table></figure>

<p><strong>关于这三种方式的简单总结</strong></p>
<ul>
<li><strong>scrollTo/scrollBy</strong>: 操作简单, 适合对View内容的滑动</li>
<li><strong>动画</strong>: 操作简单,主要适用于没有交互的View和实现复杂的动画效果.</li>
<li><strong>修改布局参数</strong>: 操作稍微复杂,适用于有交互的View.</li>
</ul>
<h2 id="弹性滑动"><a href="#弹性滑动" class="headerlink" title="弹性滑动"></a>弹性滑动</h2><p><strong>使用Scroller</strong></p>
<p>一个简单的使用方法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scroller mScroller = <span class="keyword">new</span> Scroller(mContent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个方法, 接收要移动到的目标点 x和y</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX, <span class="keyword">int</span> destY)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> scrollX = getScrollX();</span><br><span class="line">    <span class="keyword">int</span> deltaX = destX - scrollX;</span><br><span class="line">    <span class="comment">// 1000ms内逐渐滑向destX</span></span><br><span class="line">    mScroller.startScroll(scrollX, <span class="number">0</span>, deltaX, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复写View的computeScroll方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mScroller.computeScrollOffset())&#123;</span><br><span class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">        postInvalidate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中<code>Scroller类中startScroll()</code>方法,其实没有实际操作什么,只是保存了调用方法时,传递的几个参数. 如: 开始结束点,时间等. <em>那动画究竟是怎么实现的? 复写的<code>computeScroll()</code>又有什么用?</em></p>
<p>流程顺序这样的: 当调用了<code>startScroll()</code>系统只是保存了一些信息, 但是下面调用<code>invalidate()</code>. 这个方法都知道是会导致View的重绘, 在View的<code>draw()</code>方法中又会去调用<code>computeScroll()</code>方法,本身<code>computeScroll()</code>是一个空实现,但是这里进行了复写. 而这个方法我们复写的时候调用了<code>scrollTo()</code>方法!  ok这样View就会真正的移动了! 但是还有一点这次滚动只是整个滚动事件的一个小部分,后续的怎么触发的? 就是下面又调用了<code>postInvalidate()</code>, 又会重新绘制重新调用computeScroll()这个复写过的空实现方法.</p>
<p>而<code>Scroller类中的computeScrollOffset()</code>可以直接返回这个滚动的动作是否全部完成. 源码实现思路就是根据时间的流逝的百分比来计算出当前ScrollX和ScrollY的值.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心代码  x就是时间流逝的百分比</span></span><br><span class="line">mCurrX = mStartX + Math.round(x * mDeltaX);</span><br><span class="line">mCurrY = mStartY + Math.round(x * mDeltaY);</span><br></pre></td></tr></table></figure>

<p>小结Scroller的工作原理:</p>
<p><code>Scroller</code>本身不可以实现滑动, 需要和<code>View的ComputeScroll()</code>配合使用来完成弹性滑动. 通过不断的在<code>computeScroll()</code>调用View的重绘方法. 每次绘制时候的当前时间与开始时间的时间差与设定的<strong>执行动画时间</strong>的百分比,算出每一次需要scroll到的坐标点, 然后通过调用**scrollTo()**来实现每一次的小滚动效果. 通过一连串的滚动达到了平滑的效果. 这就是<code>Scroller</code>工作机制. 完全实现了解耦操作. 这个过程没有任何一处对View进行引用,甚至连内部计时器都没有.</p>
<p><strong>通过动画</strong></p>
<p>可以直接使用<code>ObjectAnimator.ofFloat(tagerView,&quot;translationX&quot;,0,100).setDuration(100).start()</code></p>
<p>也可以利用动画的特性, 实现与Scroller原理近似的方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> startX = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> endX = <span class="number">200</span>;</span><br><span class="line">ValueAnimator valueAnimator = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">1</span>).setDuration(<span class="number">1000</span>);</span><br><span class="line">valueAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> offset = (<span class="keyword">int</span>) animation.getAnimatedFraction();</span><br><span class="line">      mTextview.scrollTo(startX+offset, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让系统算出每个时间片我们需要移动的距离, 并回调给我们.让我们自己实现. 如果是一组动画在相同的时间执行的绝对值相同我们就可以在<code>onAnimationUpdate()</code>一起进行调用.</p>
<p><strong>使用延时策略</strong></p>
<blockquote>
<p>核心思想就是通过发送一些列延时消息从而达到一种渐进的效果.</p>
</blockquote>
<p>可以使用: <code>Handler</code>, <code>View的postDelayed()</code>方法, 或者线程的<code>sleep()</code></p>
<h2 id="View事件分发机制"><a href="#View事件分发机制" class="headerlink" title="View事件分发机制"></a>View事件分发机制</h2><h3 id="点击事件传递规则"><a href="#点击事件传递规则" class="headerlink" title="点击事件传递规则"></a>点击事件传递规则</h3><blockquote>
<p>所谓点击事件的事件分发,就是对MotionEvent事件的分发过程,传递给某一个View.</p>
</blockquote>
<p>在事件传递中有三个方法是贯穿始终的</p>
<ul>
<li><code>dispatchTouchEvent()</code>:进行事件的分发 如果事件能传递到View那么此方法一定会被调用,返回值受当前View的<code>onTouchEvent()</code>和下级View的<code>dispatchTouchEvent()</code>的影响. 表示是否消耗当前事件.</li>
<li><code>onInterceptTouchEvent()</code>: 判断是否拦截事件,如果当前View拦截了某个事件,那么在同一个事件序列中, 此方法不会被再次调用, 返回结果表示是否拦截当前事件.</li>
<li><code>onTouchEvent()</code>: 在dispatchTouchEvent中被调用. 用来处理点击事件, 返回结果表示是否消耗当前事件,如果不消耗, 则在同一个事件序列中, 当前View无法再次接收到事件.</li>
</ul>
<p>如果把源码中的各种判断去掉, 只留最核心的代码, 那么就如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;   <span class="comment">//表示这个事件最终的处理结果</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (onInterceptTouchEvent(event))&#123;</span><br><span class="line">        <span class="comment">//事件被拦截自己处理</span></span><br><span class="line">       consume = onTouchEvent(event);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//事件被分发到子view的dispatchTouchEvent()中</span></span><br><span class="line">       consume = child.dispatchTouchEvent(event);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>OnTouchListener() , onTouchEvent() , OnClickListener() 的优先级</strong></p>
<p>上面说了普遍情况下的事件分发. 如果这个View同时还添加了<code>OnTouchListener</code>和<code>OnClickListener</code>. 此时的优先级如下:</p>
<blockquote>
<p>OnTouchListener –&gt; onTouchEvent –&gt; OnClickListener</p>
</blockquote>
<p>而<code>onTouchEvent()</code>能否被最终调用取决于<strong>设置了OnTouchListener()中的<code>onTouch()</code>的返回值</strong>, 如果<code>onTouch()</code>返回的结果是false,那么<code>onTouchEvent()</code>会被调用. 如果返回true那么<code>onTouchEvent()</code>不会被调用. </p>
<p>而最后被调用的<code>OnClickListener()</code>方法是在<code>onTouchEvent()</code>被调用的. 所以如果<code>onTouchEvent()</code>方法如果执行, 那么对应的添加的<code>onClickLisener()</code>才会被调用. 所以如果在<code>OnTouchListener()中的onTouch()返回true</code>那么<code>onTouchEvent()不会被调用,内部调用OnClickListener也就更无法被调用</code>.</p>
<p><strong>一个事件的传递过程遵循如下</strong></p>
<blockquote>
<p>Activity -&gt; Window -&gt; View</p>
</blockquote>
<p>如果事件一直不拦截,传递到了最里层的View而最里层的View的<code>onTouchEvent()</code>也返回false不消费, 那么事件就会向上级的<code>onTouchEvent()</code>传递,如果还返回false就依次传递.</p>
<p>对于事件机制的规则:</p>
<ol>
<li><strong>事件序列</strong>是指按下到抬起之间发生的一系列事件. </li>
<li>默认一个事件序列只能被一个View拦截并消耗. (例外:采用非常规,在onTouchEvent强行传递给其他View. 不推荐)</li>
<li>如果View决定拦截,那么这个事件序列只能由它自己处理. 并且它的<code>onInterceptTouchEvent()</code>不会再被调用</li>
<li>如果View不在<code>ACTION_DOWN</code>事件时返回true, 那么同一个事件序列都不会再交给它来处理.并且事件会重新传递到父元素的<code>onTouchEvent()</code>再次调用方法.</li>
<li>如果View不消耗除<code>ACTION_DOWN</code>以外的事件,那么这个点击事件会消失,而父元素的<code>onTouchEvent()</code>不会被调用,并且当前View可以持续收到后续的事件,最终这些消失的事件会传递到activity处理.</li>
<li><code>ViewGroup</code>默认不拦截任何事件, 源码中ViewGroup的<code>onInterceptTouchEvent()</code>默认返回false</li>
<li><code>View</code>没有<code>onInterceptTouchEvent()</code>, 因为它没有子View,所以直接调用<code>onTouchEvent()</code></li>
<li><code>View</code>的<code>onTouchEvent</code>默认都会消耗事件返回true. 除非它不可点击的(需要<code>clickable</code>,<code>longClickable</code>同时为false). View的<code>longClickable</code>默认都为false. 而<code>clickable</code>需要区分控件, 如<code>Button</code>默认为true, <code>TextView</code>默认为false.</li>
<li><code>View</code>的<code>enable</code>属性不影响<code>onTouchEvent</code>的默认返回值, 哪怕一个View是<code>disable</code>状态. 只要它的<code>clickable</code>或者<code>longClickable</code>有一个为true. 那么它的<code>onTouchEvent()</code>就返回true.</li>
<li><code>onClick</code>会发生的前提是当前View为可点击, 并且他收到了down和up事件.</li>
<li>事件传递的过程是由外向内的. 通过<code>requestDisallowInterceptTouchEvent()</code>可以在子元素中干预父元素的事件分发过程,但是<code>ACTION_DOWN</code>事件除外.</li>
</ol>
<h3 id="事件分发的源码解析"><a href="#事件分发的源码解析" class="headerlink" title="事件分发的源码解析"></a>事件分发的源码解析</h3><p><strong>1.Activity对点击事件的分发过程</strong></p>
<p>事件的起始<code>Activity</code>的<code>dispatchTouchEvent()</code>进行分发,具体的工作交由内部的<strong>Window</strong>来完成. <strong>window</strong>会将事件传递给<strong>decor view</strong>. 而<strong>decor view</strong>一般是当前界面的底层容器(平常setContentView中传递的布局),可通过<code>Activity.getWindow.getDecorView()</code>获得.</p>
<p><strong>window</strong>是怎样将事件传递给<code>ViewGroup</code>的? 首先Window类为一个抽象类,而类中的调用的分发方法也为抽象方法. 所以需要找到实现类. Window的唯一实现类<code>PhoneWindow</code>. 这个类会在被实例化的时候会被重构.</p>
<p><code>PhoneWindow#superDispatchTouchEvent(ev)</code>方法中将事件传递给了DecorView.</p>
<p>decorView就是挂载我们的layout布局的<strong>顶级View</strong>,继承<code>FrameLayout</code>.  </p>
<p><code>((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0);</code></p>
<p>这个方法可以获取到Activity所设置的View. 所以之间的关系很清楚了. 事件先交给最顶级的DecorView然后交由我们设置的View.</p>
<p><strong>2.ViewGroup对事件的处理</strong></p>
<p>在父元素中判断子元素是否能接收点击事件的主要由两个因素衡量: 子元素是否在播放动画和点击事件的坐标是否落在子元素的区域内.<code>dispatchTransformedTouchEvent()</code>实际就是调用子View的<code>dispatchTouchEvent</code>. 而在事件从孩子到父元素(子View在<code>onTouchEvent</code>返回false). 其实也是调用了<code>dispatchTransformedTouchEvent()</code>. 区别就在于向内传递参数3是传入的不是空值, 向外传传入的是null.看下面代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="params"><span class="function">            View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">     handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     handled = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>3.View对事件的处理</strong></p>
<ol>
<li>View对事件的判断首先是检测是否有<code>onTouchListener</code>如果有那么就调用其中的<code>onTouch()</code>方法.</li>
<li>然后执行<code>onTouchEvent()</code>这里有个判断条件,如果在<code>onTouchListener()</code>返回true. 那么if中的条件判断第一个就不会成立,也就不会再调用<code>onTouchEvent()</code>方法.如下:</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">               &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">               &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">           result = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line"> result = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>然后在<code>onTouchEvent()</code>中首先是查看View处理不可用状态. 这里需要注意一下, 虽然View不可用但是如果点击标记或者长按点击标记都是<code>true</code>. 那么事件也会被消费.如下</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">       .....</span><br><span class="line">           <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">           <span class="comment">// events, it just doesn&#x27;t respond to them.</span></span><br><span class="line">           <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                   || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                   || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>如果View设置有代理, 那么还会执行<code>TouchDelegate的onTouchEvent()</code></li>
<li>然后对点击状态进行处理.首先如果<strong>点击</strong>和<strong>长按</strong>有一个为true那么就会消费事件. 即<code>onTouchEvent()</code>返回true.  然后在<code>ACTION_UP</code>中会触发<code>performClick()</code>如果设置了<code>onClickListener()</code>那么就会在此处进行判断并调用<code>onClick()</code>.</li>
<li>上面一直说的<strong>LONG_CLICKABLE</strong>与<strong>CLICKABLE</strong>. 长按标记默认为false. 点击标记和View是否是可点击View有关系. 如button可点击默认就是true. 否者反之.  在使用时可以通过<code>setClickable</code>和<code>setLongClickable</code>对View的这两个标记进行修改. 这里还要注意还有一种赋值方式. 如果设置了<code>setOnClickListener()</code>或者<code>setOnLongClickListener()</code>监听的话那么会自动将其对应的属性置为true.</li>
</ol>
<h2 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a>View的滑动冲突</h2><h3 id="滑动冲突的解决方式"><a href="#滑动冲突的解决方式" class="headerlink" title="滑动冲突的解决方式"></a>滑动冲突的解决方式</h3><p><strong>外部拦截法</strong></p>
<blockquote>
<p>是指点击事件都是需要先经过父容器的拦截处理, 如果父容器需要此事件就拦截,不需要就下放. 外部拦截需要重写父容器的onInterceptTouchEvent方法</p>
</blockquote>
<p>简述一下: 如果使用这样拦截法. 那么首先</p>
<ul>
<li><code>ACTION_DOWN</code>这个事件,父容器必须返回false, 即不拦截<code>ACTION_DOWN</code>事件, 因为一旦父容器拦截了这个事件, 那么后续的<code>ACTION_MOVE</code>,<code>ACTION_UP</code>事件都会交由父容器来处理了. 这个时候这个<strong>事件序列</strong>剩余部分无法传递给子元素了.</li>
<li><code>ACTION_MOVE</code>这个事件,就可以根据实际的需求来决定是否需要拦截. 如果需要拦截就返回true.否则false.</li>
<li><code>ACTION_UP</code>这个事件必须返回false, 因为<code>ACTION_UP</code>事件本身没有太多意义.</li>
</ul>
<p><strong>内部拦截法</strong></p>
<blockquote>
<p>是指父容器不拦截任何事件, 所有的事件都需要传递给子元素, 如果子元素需要此事件就直接消费. 否则就交由父容器进行处理, 由于这种方法和Android中的事件分发机制不一致, 需要配合requestDisallowInterceptTouchEvent()方式才能正常工作. 需要重写子元素的dispatchTouchEvent</p>
</blockquote>
<p>这种拦截法的使用规则:</p>
<p>子View中的<code>dispatchTouchEvent()</code>进行复写.</p>
<ul>
<li><code>ACTION_DOWN</code>事件中: 让父容器拒绝拦截所有事件, 调用<code>parent.requestDisallowInterceptTouchEvent(true)</code></li>
<li><code>ACTION_MOVE</code>事件中: 进行条件的拦截判断, 如果在某一种场景需要拦截,那么就调用方法允许父容器拦截事件.</li>
<li><code>return</code> 时, 调用<code>super.dispatchTouchEvent(event)</code></li>
</ul>
<p>父容器的<code>onInterceptTouchEvent()</code>进行<code>ACTION_DOWN</code>返回false, 其余都是返回true的复写.</p>
<p>说明一点, 为什么父容器不连<code>Action_down</code>一并的用true复写.  因为<code>ACTION_DOWN</code>这个事件是不受<code>INTERCEPT_FLAG</code>这个标记影响的的, 就是不管拦截标记是否是何值, 按下事件必然会执行, 所以如果这里返回true,  那么就代表着, 这个事件序列的后续部分将由父容器进行处理, 而子容器无法收到这个事件.</p>
<h2 id="实例演练"><a href="#实例演练" class="headerlink" title="实例演练"></a>实例演练</h2><p><a target="_blank" rel="noopener" href="https://github.com/suzeyu1992/Notes_AndroidDevSeek">实例演练的代码</a></p>
<p><strong>实现效果:类似ViewPager中嵌套ListView的效果</strong></p>
<p>首先需要一个父容器, 这里使用作者提供的一个类<code>MyHorizontalScrollView</code>,这个类类似于<code>ViewPager</code>是继承<code>ViewGroup</code>自定义的, 支持左右滑动. 因为这个类对拦截进行了处理,所以这里把<code>onInterceptTouchEvent()</code>实现的方法注释掉让这个自定义ViewGroup走默认的分发模式.  达到一会使用可以出现滑动冲突的场景. (关于这个类的其他代码,会在下一章笔记中说明,这里不需要关心)</p>
<p>然后子容器是一个<code>TextView</code>+<code>ListView</code>. </p>
<p><strong>分析存在的问题</strong></p>
<p>由于<code>ViewGroup</code>默认的是不拦截事件的. 在自己的<code>onTouchEvent</code>进行了事件的处理来实现左右滑动. 但是这里有有一个前提, 那就是事件一直传递到最里层并且最里层的<code>View</code>不会把事件消费掉.这样父容器才会实现预期的效果. </p>
<p>但是这里放了一个<code>listview</code>, <code>TextView</code>. 运行代码看一下实际情况.  发现如下情况:</p>
<p><img src="outside.png"></p>
<h3 id="外部拦截解决"><a href="#外部拦截解决" class="headerlink" title="外部拦截解决"></a>外部拦截解决</h3><p><em>外部拦截法相关代码在仓库的outside包中</em></p>
<p>接下来就解决这个问题.  既然打算外部拦截法,那么首先继承这个<code>MyHorizontalScrollView</code>类, 复写其中的<code>onInterceptTouchEvent()</code>进行相应的处理. </p>
<p>需要解决的就是在:<strong>滑动过程中水平距离差比垂直距离差大,父容器就要拦截事件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> intercept = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line"><span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> (ev.getAction())&#123;</span><br><span class="line">       <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">           <span class="keyword">if</span> (!mScroller.isFinished())&#123;</span><br><span class="line">               mScroller.abortAnimation();  <span class="comment">//优化滑动效果</span></span><br><span class="line">               intercept = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">           <span class="keyword">int</span> deltaX = x - mLastYIntercept;</span><br><span class="line">           <span class="keyword">int</span> deltaY = y - mLastYIntercept;</span><br><span class="line">           <span class="comment">//根据绝对值判断是否需要拦截</span></span><br><span class="line">           <span class="keyword">if</span> (Math.abs(deltaX) &lt; Math.abs(deltaY))&#123;</span><br><span class="line">               intercept = <span class="keyword">false</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               intercept = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">           intercept = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//赋值给mLast是防止在onTouchEvent第一次move移动时候跳屏</span></span><br><span class="line">   mLastX = mLastXIntercept = x;</span><br><span class="line">   mLastY = mLastYIntercept = y;</span><br><span class="line">   <span class="keyword">return</span> intercept;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="内部拦截解决"><a href="#内部拦截解决" class="headerlink" title="内部拦截解决"></a>内部拦截解决</h3><p><em>内部拦截法相关代码在仓库的inside包中</em></p>
<p>上面总结过使用内部拦截法. 主要就是允许父容器在<code>onIntercept()</code>中的<code>MOVE和UP事件中一直返回true</code>表示拦截事件.  而在子容器中进行对父容器的<code>requestDisallowIntercept</code>标记的修改. 来控制事件的分发.(<code>DOWN</code>事件不能返回true,会导致子View永远收不到事件)</p>
<p>子容器这里<code>ListView</code>进行继承并复写<code>dispatchTouchEvent()</code>,来控制父容器的<code>requestDisallowIntercept</code>标记.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction())&#123;</span><br><span class="line">      <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">          <span class="comment">//相当于进行初始化每次发生一个事件序列时, 都对不容器进行重置不允许拦截</span></span><br><span class="line">          mInSide2HorizontalScrollview.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">          <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">          <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">    </span><br><span class="line">          <span class="keyword">if</span> (Math.abs(deltaX) &gt; Math.abs(deltaY))&#123;</span><br><span class="line">              <span class="comment">//当水平距离大的时候 允许父容器拦截</span></span><br><span class="line">              mInSide2HorizontalScrollview.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">    </span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时修改一下父容器的<code>onInterceptTouchEvent()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">   <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">switch</span> (ev.getAction())&#123;</span><br><span class="line">       <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">           <span class="keyword">if</span> (!mScroller.isFinished())&#123;</span><br><span class="line">               mScroller.abortAnimation();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           mLastX = x;</span><br><span class="line">           mLastY = y;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>好啦 结束了 慢慢消化….</p>
</blockquote>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2016/08/10/《Android开发艺术探索》04-View的工作原理/" data-toggle="tooltip" data-placement="top" title="《Android 开发艺术探索》 04-View的工作原理">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2016/08/02/Android开发艺术探索-笔记02-IPC机制/" data-toggle="tooltip" data-placement="top" title="《Android 开发艺术探索》 02-IPC机制">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">文章目录</a>
                    </h5>
                    <ul class="catalog-body" style="padding-left: 0%; list-style:none;  width: 150%"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#android" title="android">android</a>
                        
                          <a class="tag" href="/tags/#笔记" title="笔记">笔记</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="#" target="_blank">Kaijun&#39;s Blog</a></li>
                    
                        <li><a href="#" target="_blank">Foo</a></li>
                    
                        <li><a href="#" target="_blank">Bar</a></li>
                    
                        <li><a href="#" target="_blank">Example Friends</a></li>
                    
                        <li><a href="#" target="_blank">It helps SEO</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "http-szysky-com";
    var disqus_identifier = "http://szysky.com/2016/08/08/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/";
    var disqus_url = "http://szysky.com/2016/08/08/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/szyskys">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/szysky">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/suzeyu1992">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://www.linkedin.com/in/szysky">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Szy&#39;sky Blog 2021
                    <br>
                    Theme by <a target="_blank" rel="noopener" href="http://huangxuan.me">Hux</a>
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span>
                    Ported by <a target="_blank" rel="noopener" href="http://blog.kaijun.rocks">Kaijun</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://szysky.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '5aca5df6308eba7bd10d5bac33225006';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>





<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>




<!-- Image to hack wechat -->
<img src="http://szysky.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
