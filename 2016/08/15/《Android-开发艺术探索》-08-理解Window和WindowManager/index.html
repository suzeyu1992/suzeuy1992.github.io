<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="suzeyu skyszy`blog">
    <meta name="keyword"  content="suzeyu skyszy`blog">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          《Android 开发艺术探索》 08-理解Window和WindowManager - 筑梦 suzeyu`苏泽钰
        
    </title>

    <link rel="canonical" href="http://szysky.com/2016/08/15/《Android-开发艺术探索》-08-理解Window和WindowManager/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/hux-blog.min.css">


    <!-- Pygments Github CSS -->
    
<link rel="stylesheet" href="/css/syntax.css">


    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Szy&#39;sky Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">

                 


                      <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','uaGE1nqtyiBMes6-h6b9','2.0.0');
</script>

                    




                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://szysky.com/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
    .h1_nav{font-size: 13px; padding-left:0%; color: #ff0000;}
    .h2_nav{font-size: 12px;padding-left: 4%;color: #ff0000; }
    .h3_nav{font-size: 11px;padding-left: 12%;}
    .h4_nav{font-size: 10px;padding-left: 18%;}
    .h5_nav{font-size: 9px;padding-left: 24%;}
    .h6_nav{font-size: 8px;padding-left: 30%;}


</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#android" title="android">android</a>
                        
                          <a class="tag" href="/tags/#笔记" title="笔记">笔记</a>
                        
                    </div>
                    <h1>《Android 开发艺术探索》 08-理解Window和WindowManager</h1>
                    <h2 class="subheading">抄书系列</h2>
                    <span class="meta">
                        Posted by Suzeyu on
                        2016-08-15
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <blockquote>
<p>第八章: 所有的视图都是Windown呈现的, 那它都干了什么?</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/suzeyu1992/Notes_AndroidDevSeek">blog相关代码保存在第7章项目window包中</a></p>
<p>Window表示一个窗口的概念, 如有需要在桌面上显示一个类似悬浮窗的东西, 那么这种效果就需要<code>Window</code>来实现. <code>Window</code>是一个抽象类, 具体实现是<code>PhoneWindow</code>. 如果想要创建一个<code>Window</code>只需要通过<code>WindowManager</code>即可完成. <code>WindowManager</code>是外界访问<code>Window</code>的入口, Window具体实现位于<code>WindowManagerService</code>中, <strong>WM</strong>和<strong>WMS</strong>的交互是一个IPC过程. Android中所有的视图都是通过<code>Window</code>来呈现的, 不管是Activity, Dialog, Toast他们的视图实际上都是附加在Window上的.</p>
<h2 id="Window和WindowManager"><a href="#Window和WindowManager" class="headerlink" title="Window和WindowManager"></a>Window和WindowManager</h2><p>先演示使用<code>WindowManger</code>添加一个Window. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWindow</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Button button = <span class="keyword">new</span> Button(getApplicationContext());</span><br><span class="line">        button.setText(<span class="string">&quot;动态添加&quot;</span>);</span><br><span class="line">        WindowManager.LayoutParams layoutParams = <span class="keyword">new</span> WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, <span class="number">0</span>, <span class="number">0</span>, PixelFormat.TRANSPARENT);</span><br><span class="line"></span><br><span class="line">        layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL</span><br><span class="line">                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</span><br><span class="line">                | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;</span><br><span class="line"></span><br><span class="line">        layoutParams.gravity = Gravity.LEFT ;</span><br><span class="line"></span><br><span class="line">        layoutParams.width = <span class="number">400</span>;</span><br><span class="line">        layoutParams.height = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">        getWindowManager().addView(button, layoutParams);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Flag参数表示Window的属性</strong>,这些属性可以控制Window的显示特性. 下面是常用的属性:</p>
<ul>
<li><code>FLAG_NOT_FOCUSABLE</code>: 表示Window不需要获取焦点, 而不需要接收各种输入事件, 此标记会同时启动<code>FLAG_NOT_TOUCH_MODAL</code>, 最终事件会直接传递给下层的具有焦点的Window.</li>
<li><code>FLAG_NOT_TOUCH_MODAL</code>: 这种模式下, 系统会将当前Window区域以外的点击事件传递给底层的Window, 当前Window区域以内的单击事件则自己处理. 这个标记很重要, 一般来说都需要开启此标记, 否则其他Window将无法接收到单击事件.</li>
<li><code>FLAG_SHOW_WHEN_LOCKED</code>: 开启此模式可以让Window显示在锁屏的界面上.</li>
</ul>
<p><strong>Type参数表示Window的类型</strong></p>
<p>Window共有三种类型, 分别是<strong>应用Window</strong>, <strong>子Window</strong>, <strong>系统Window</strong>. 应用类Window对应着一个Activity. 子Window不能单独存在, 他需要附属在特定的父Window中,比如常见的<code>Dialog</code>就是一个子Window. 系统Window是需要声明权限才能创建的Window, 比如<code>Toast</code>和系统状态栏都是系统的Window.</p>
<p>Window是分层的, 每个Window都有对应的<code>z-ordered</code>, 层级大的会覆盖在层级小的Window的上面, 这和HTML中的<code>z-index</code>的概念一样. <strong>应用Window</strong>的层级范围是1<del>99, <strong>子Window</strong>的层级范围是1000</del>1999, <strong>系统Window</strong>的层级范围是2000~2999.</p>
<p>如果想要在最顶层显示, 可以选择使用<code>TYPE_SYSTEM_OVERLAY</code>, <code>TYPE_SYSTEM_ERROR</code>. 如果采用了<code>TYPE_SYSTEM_ERROR</code>同时要声明权限<code>android.permission.SYSTEM_ALERT_WINDOW</code>. 如果不声明那么在创建的时候就会报错.</p>
<p><strong>WindowManager常用的功能</strong></p>
<p>在<code>ViewManager</code>接口中定义了三个方法. 就是我们常用的方法<strong>添加View</strong>,<strong>删除View</strong>,<strong>修改View</strong>. <code>WM</code>继承了这个接口.</p>
<h2 id="Window的内部机制"><a href="#Window的内部机制" class="headerlink" title="Window的内部机制"></a>Window的内部机制</h2><p><code>Window</code>是一个抽象的概念, 每一<code>Window</code>都对应着一个View和一个ViewRootImpl, <code>Window</code>和View通过<code>ViewRootImpl</code>来建立联系, 因此Window并不是实际存在的, 他是以View的形式存在. 通过<code>WindowManager</code>的定义和提供的三个接口方法看出都是针对View的. 说明View才是<code>Windwo</code>存在的实体. 而在实际的使用中无法直接访问<code>Window</code>, 对<code>Window</code>的访问都是必须通过WM. </p>
<h3 id="Window的添加过程"><a href="#Window的添加过程" class="headerlink" title="Window的添加过程"></a>Window的添加过程</h3><p><code>Window</code>的添加过程需要通过<code>WindowManager</code>的<code>addView()</code>来实现, 而<code>WindowManager</code>是一个接口, 它的真正实现是<code>WindowManagerImpl</code>类, 在WindowManagerImpl中Window的三大操作如下.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">   applyDefaultToken(params);</span><br><span class="line">   mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">   applyDefaultToken(params);</span><br><span class="line">   mGlobal.updateViewLayout(view, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">   mGlobal.removeView(view, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WindowManagerImpl</code>并没有直接实现Window的三大操作, 而是全部交给了<code>WindowManagerGlobal</code>来处理. <code>WindowManagerGlobal</code>以工厂的形式向外提供自己的实例. 而<code>WindowManagerImpl</code>这种工作模式就典型的桥接模式, 将所有的操作全部委托给<code>WindowManagerGlobal</code>来实现.</p>
<p><strong>WindowManagerGlobal的addView()主要分为</strong></p>
<ol>
<li>检查所有参数是否合法, 如果是子Window那么还需要调整一些布局参数.</li>
<li>创建<code>ViewRootImpl</code>并将View添加到列表中. </li>
<li>通过<code>ViewRootImpl</code>来更新界面并完成Window的添加过程. 这个过程是通过<code>ViewRootImpl#setView()</code>来完成的. View的绘制过程是由<code>ViewRootImpl</code>来完成的, 在内部会调用<code>requestLayout()</code>来完成异步刷新请求. 而<code>scheduleTraversals()</code>实际上是View绘制的入口.  接着会通过<code>WindowSession</code>完成Window的添加过程(Window的添加过程是一次IPC调用). 最终会通过<code>WindowManagerService</code>来实现Window的添加.</li>
</ol>
<p><code>WindowManagerService</code>内部会为每一个应用保留一个单独的Session. </p>
<h3 id="Window的删除过程"><a href="#Window的删除过程" class="headerlink" title="Window的删除过程"></a>Window的删除过程</h3><p>Window 的删除过程和添加过程一样, 都是先通过<code>WindowManagerImpl</code>后, 在进一步通过<code>WindowManagerGlobal的removeView()</code>来实现的. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">       <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</span><br><span class="line">       View curView = mRoots.get(index).getView();</span><br><span class="line">       removeViewLocked(index, immediate);</span><br><span class="line">       <span class="keyword">if</span> (curView == view) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Calling with view &quot;</span> + view</span><br><span class="line">               + <span class="string">&quot; but the ViewAncestor is attached to &quot;</span> + curView);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内首先通过<code>findViewLocked</code>来查找待删除的View的索引, 这个过程就是建立数组遍历, 然后调用<code>removeViewLocked</code>来做进一步的删除.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeViewLocked</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">   ViewRootImpl root = mRoots.get(index);</span><br><span class="line">   View view = root.getView();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">       InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">       <span class="keyword">if</span> (imm != <span class="keyword">null</span>) &#123;</span><br><span class="line">           imm.windowDismissed(mViews.get(index).getWindowToken());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">boolean</span> deferred = root.die(immediate);</span><br><span class="line">   <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">       view.assignParent(<span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">           mDyingViews.add(view);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过<code>ViewRootImpl</code>的<code>die()</code>完成来完成删除操作. <code>die()</code>方法只是发送了请求删除的消息后就立刻返回了, 这个时候View并没有完成删除操作, 所以最后会将其添加到<code>mDyingViews</code>中, <code>mDyingViews</code>表示待删除的View的列表. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">die</span><span class="params">(<span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Make sure we do execute immediately if we are in the middle of a traversal or the damage</span></span><br><span class="line">   <span class="comment">// done by dispatchDetachedFromWindow will cause havoc on return.</span></span><br><span class="line">   <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;</span><br><span class="line">       doDie();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!mIsDrawing) &#123;</span><br><span class="line">       destroyHardwareRenderer();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       Log.e(TAG, <span class="string">&quot;Attempting to destroy the window while drawing!\n&quot;</span> +</span><br><span class="line">               <span class="string">&quot;  window=&quot;</span> + <span class="keyword">this</span> + <span class="string">&quot;, title=&quot;</span> + mWindowAttributes.getTitle());</span><br><span class="line">   &#125;</span><br><span class="line">   mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>die方法中只是做了简单的判断, 如果是异步删除那么就发送一个<code>MSG_DIE</code>的消息, <code>ViewRootImpl</code>中的<code>Handler</code>会处理此消息并调用<code>doDie()</code>; 如果是同步删除, 那么就不发送消息直接调用<code>doDie()</code>方法. </p>
<p>在<code>doDie()</code>方法中会调用<code>dispatchDetachedFromWindow()</code>方法, 真正删除View的逻辑在这个方法内部实现. 其中主要做了四件事:</p>
<ol>
<li>垃圾回收的相关工作, 比如清除数据和消息,移除回调.</li>
<li>通过Session的remove方法删除Window: <code>mWindowSession.remove(mWindow)</code>, 这同样是一个IPC过程, 最终会调用<code>WMS</code>的removeWindow()方法.</li>
<li>调用View的<code>dispatchDetachedFromWindow()</code>方法, 内部会调用View的<code>onDetachedFromWindow()</code>以及<code>onDetachedFromWindowInternal()</code>. 而对于<code>onDetachedFromWindow()</code>就是在View从Window中移除时, 这个方法就会被调用, 可以在这个方法内部做一些资源回收的工作. 比如停止动画,停止线程</li>
<li>调用<code>WindowManagerGlobal#doRemoveView</code>方法刷新数据, 包括<code>mRoots</code>, <code>mParams</code>, <code>mDyingViews</code>, 需要将当前Window所关联的这三类对象从列表中删除.</li>
</ol>
<h3 id="Window的更新过程"><a href="#Window的更新过程" class="headerlink" title="Window的更新过程"></a>Window的更新过程</h3><p><code>WindowManagerGlobal#updateViewLayout()</code>方法做的比较简单, 它需要更新View的<code>LayoutParams</code>并替换掉老的<code>LayoutParams</code>, 接着在更新<code>ViewRootImpl</code>中的LayoutParams. 这一步主要是通过<code>setLayoutParams()</code>方法实现.</p>
<p>在<code>ViewRootImpl</code>中会通过<code>scheduleTraversals()</code>来对View重新布局, 包括测量,布局,重绘. 除了View本身的重绘以外, <code>ViewRootImpl</code>还会通过<code>WindowSession</code>来更新Window的视图, 这个过程最后由<code>WMS</code>的<code>relayoutWindow()</code>实现同样是一个IPC过程.</p>
<h2 id="Window的创建过程"><a href="#Window的创建过程" class="headerlink" title="Window的创建过程"></a>Window的创建过程</h2><p>View是Android中视图的呈现方式, 但是View不能单独存在, 它必须依附在Window这个抽象的概念上面, 因此有视图的地方就有<code>Window</code>. </p>
<h3 id="Activity的Window创建过程"><a href="#Activity的Window创建过程" class="headerlink" title="Activity的Window创建过程"></a>Activity的Window创建过程</h3><p><code>Activity</code>的大体启动流程: 最终会由<code>ActivityThread</code>中的<code>PerformLaunchActivity()</code>来完成整个启动过程, 这个方法内部会通过类加载器创建<code>Activity</code>的实例对象, 并调用其<code>attach()</code>方法为其关联运行过程中所依赖的一系列上下文环境变量. 代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">  Activity activity = <span class="keyword">null</span>;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//获得类加载器</span></span><br><span class="line">  java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">  activity = mInstrumentation.newActivity(</span><br><span class="line">          cl, component.getClassName(), r.intent);</span><br><span class="line">  StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">  r.intent.setExtrasClassLoader(cl);</span><br><span class="line">  r.intent.prepareToEnterProcess();</span><br><span class="line">  <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">      r.state.setClassLoader(cl);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line"> CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line"> Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">     </span><br><span class="line"> activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">         r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">         r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">         r.referrer, r.voiceInteractor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>attach()</code>方法里, 系统会创建<code>Activity</code>所属的Window对象并为其设置回调接口, Window对象的创建是通过<code>PolicyManager#makeNewWindow()</code>方法实现. 由于<code>Activity</code>实现了<code>Window</code>的CallBack接口, 因此当<code>Window</code>接收到外界的状态改变的时候就会回调Activity方法. 比如说我们熟悉的<code>onAttachedToWindow()</code>, <code>onDetachedFromWindow()</code>, <code>dispatchTouchEvent()</code>等等.代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>);</span><br><span class="line">       mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">       mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">       mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">           mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (info.uiOptions != <span class="number">0</span>) &#123;</span><br><span class="line">           mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">       &#125;</span><br><span class="line">       mUiThread = Thread.currentThread();</span><br></pre></td></tr></table></figure>

<p>那么Activity视图是怎么附属在Window上的呢? 查看经常使用的<code>setContentView()</code>方法干了什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">   getWindow().setContentView(layoutResID);</span><br><span class="line">   initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Activity</code>将具体实现交给了Window处理, 而<code>Window</code>的具体实现就是<code>PhoneWindow</code>, 所以只需要看<code>PhoneWindow</code>的相关逻辑分为以下几步.</p>
<ol>
<li>如果没有DecorView, 那么就创建它. 由<code>installDecor()--&gt;generateDecor()</code>触发</li>
<li>将View添加到<code>DecorView</code>的<code>mContentParent</code>中</li>
<li>回调Activity的<code>onContentChanged()</code>通知activity视图已经发生改变 </li>
</ol>
<p>这个时候<code>DecorView</code>已经被创建并初始化完毕, Activity的布局文件也已经添加成功到<code>DecorView的mContentParent</code>中. 但是这个时候<code>DecorView</code>还没有被<code>WindowManager</code>正式添加到Window中. 虽然早在<code>Activity的attach</code>方法中window就已经被创建了, 但是这个时候由于<code>DecorView</code>并没有被<code>WindowManager</code>识别, 所以这个时候的Window无法提供具体功能, 因为他还无法接收外界的输入信息. </p>
<p>在<code>ActivityThread#handleResumeActivity()</code>方法中, 首先会调用<code>Activity#onResume()</code>, 接着会调用<code>Activity#makeVisible()</code>, 正是在makeVisible方法中, <code>DecorView</code>真正的完成了添加和显示这两个过程. 如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">       ViewManager wm = getWindowManager();</span><br><span class="line">       wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">       mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Dialog的Window创建过程"><a href="#Dialog的Window创建过程" class="headerlink" title="Dialog的Window创建过程"></a>Dialog的Window创建过程</h3><p><code>Dialog</code>的<code>Window</code>的创建过程和Activity类似, 有如下几步</p>
<p><strong>1. 创建Window</strong></p>
<p>Dialog的创建后的实际就是<code>PhoneWindow</code>, 这个过程和Activity的Window创建过程一致.</p>
<p><strong>2. 初始化DecorView并将Dialog的视图添加到DecorView中</strong></p>
<p>这个过程也类似, 都是通过<code>Window</code>去添加指定的布局文件.</p>
<p><strong>3. 将DecorView添加到Window中并显示</strong></p>
<p>在<code>Dialog</code>的show方法中, 会通过<code>WindowManager</code>将<code>DecorView</code>添加Window中.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mWindowManager.addView(mDecor, l);</span><br><span class="line">mShowing = <span class="keyword">true</span>;   </span><br><span class="line">sendShowMessage();</span><br></pre></td></tr></table></figure>

<p>普通的<code>Dialog</code>有一个特殊之处, 那就是必须采用<code>Activity</code>的Content, 如果采用<code>Application</code>的Content, 那么就会报错.  报的错<strong>是没有应用token所导致的, 而应用token一般只有Activity才拥有</strong>. </p>
<p>还有一种方法. <code>系统Window比较特殊, 他可以不需要token</code>, 因此只需要指定对话框的Window为系统类型就可以正常弹出对话框. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JAVA 给Dialog的Window改变为系统级的Window</span></span><br><span class="line">dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//XML 声明权限</span></span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;</span>/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Toast的Window创建过程"><a href="#Toast的Window创建过程" class="headerlink" title="Toast的Window创建过程"></a>Toast的Window创建过程</h3><p><code>Toast</code>和<code>Dialog</code>不同, 它的工作过程就稍显复杂. 首先<code>Toast</code>也是基于Window来实现的. 但是由于<code>Toast</code>具有定时取消的功能, 所以系统采用了<code>Handler</code>. 在<code>Toast</code>的内部有两类IPC过程, 第一类是Toast访问<code>NotificationManagerService()</code>后面简称<code>NMS</code>. 第二类是<code>NotificationManagerService</code>回调Toast里的<code>TN</code>接口. </p>
<p><code>Toast</code>属于系统Window, 它内部的视图有两种方式指定, 一种是系统默认的样式, 另一种是通过<code>setView</code>方法来指定一个自定义View. 不管如何, 他们都对应<code>Toast</code>的一个View类型的内部成员<code>mNextView</code>. Toast内部提供了<code>cancel</code>和<code>show</code>两个方法. 分别用于显示和隐藏<code>Toast</code>. 他们内部是一个IPC过程.</p>
<p>显示和隐藏<code>Toast</code>都是需要通过<code>NMS</code>来实现的. 由于<code>NMS</code>运行在系统的进程中, 所以只能通过远程调用的方式来显示和隐藏<code>Toast</code>. 而<code>TN</code>这个类是一个<code>Binder</code>类. 在<code>Toast</code>和<code>NMS</code>进行IPC的过程中, 当NMS处理Toast的显示或隐藏请求时会跨进程回调<code>TN</code>的方法. 这个时候由于<code>TN</code>运行在Binder线程池中, 所以需要通过<code>Handler</code>将其切换到当前主线程. 所以由其可知, <code>Toast</code>无法在没有<code>Looper</code>的线程中弹出, 因为Handler需要使用<code>Looper</code>才能完成切换线程的功能.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!isSystemToast) &#123;</span><br><span class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> N = mToastQueue.size();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> ToastRecord r = mToastQueue.get(i);</span><br><span class="line">        <span class="keyword">if</span> (r.pkg.equals(pkg)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// MAX_PACKAGE_NOTIFICATIONS == 50</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123; </span><br><span class="line">                Slog.e(TAG, <span class="string">&quot;Package has already posted &quot;</span> + count</span><br><span class="line">                       + <span class="string">&quot; toasts. Not showing more. Package=&quot;</span> + pkg);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于非系统应用来说, 最多能同时存在对<code>Toast</code>封装的<code>ToastRecord</code>上限为50个. 这样做是为了防止<strong>DOS(Denial of Service)</strong>. 如果不这样, 当通过大量循环去连续的弹出Toast, 这将会导致其他应用没有机会弹出Toast, 那么对于其他应用的Toast请求, 系统的行为就是拒绝服务, 这就是拒绝服务攻击的含义.</p>
<p>在<code>ToastRecord</code>被添加到<code>mToastQueue()</code>中后, <code>NMS</code>就会通过<code>showNextToastLocked()</code>方法来显示当前的Toast. </p>
<p>Toast的显示是由<code>ToastRecord</code>的<code>callback</code>来完成的. 这个<code>callback</code>实际上就是<code>Toast</code>中的<code>TN</code>对象的远程Binder. 通过callback来访问TN中的方法是需要跨进程的. 最终被调用的<code>TN</code>中的方法会运行在发起<code>Toast</code>请求的应用的Binder线程池.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleTimeoutLocked</span><span class="params">(ToastRecord r)</span></span>&#123;</span><br><span class="line">   mHandler.removeCallbacksAndMessages(r);</span><br><span class="line">   Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r);</span><br><span class="line">   <span class="keyword">long</span> delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;</span><br><span class="line">   mHandler.sendMessageDelayed(m, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码就是在<code>Toast</code>显示以后, <code>NMS</code>通过这个方法来发送一个延时消息, 具体取决Toast的时长. <code>LONG_DELAY</code>, <code>SHORT_DELAY</code>分别对应着3.5秒和2秒. 当延时时间达到的时候. <code>NMS</code>会通过<code>cancelToastLocked()</code>方法来隐藏<code>Toast</code>并将其从<code>mToastQueue</code>中移除, 这个时候如果<code>mToastQueue</code>中还有其余<code>Toast</code>那么<code>NMS</code>就继续显示其他.</p>
<p><strong>Toast的隐藏也会通过ToastRecord的callback完成的</strong>.同样是一次IPC过程. 方式和Toast显示类似.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancelToastLocked</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">ToastRecord record = mToastQueue.get(index);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  record.callback.hide();</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">  Slog.w(TAG, <span class="string">&quot;Object died trying to hide notification &quot;</span> + record.callback</span><br><span class="line">          + <span class="string">&quot; in package &quot;</span> + record.pkg);</span><br><span class="line">  <span class="comment">// don&#x27;t worry about this, we&#x27;re about to remove it from</span></span><br><span class="line">  <span class="comment">// the list anyway</span></span><br><span class="line">&#125;</span><br><span class="line">mToastQueue.remove(index);</span><br><span class="line">keepProcessAliveLocked(record.pid);</span><br><span class="line"><span class="keyword">if</span> (mToastQueue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// Show the next one. If the callback fails, this will remove</span></span><br><span class="line">  <span class="comment">// it from the list, so don&#x27;t assume that the list hasn&#x27;t changed</span></span><br><span class="line">  <span class="comment">// after this point.</span></span><br><span class="line">  showNextToastLocked();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上基本说明<code>Toast</code>的显示和影响过程实际上是通过<code>Toast</code>中的<code>TN</code>这个类来实现的. 他有两个方法<code>show()</code>, <code>hide()</code>. 分别对应着<code>Toast</code>的显示和隐藏. 由于这两个方法是被<code>NMS</code>以跨进程的方式调用的, 因此他们运行在<code>Binder线程池中</code>. 为了将执行环境切换到Toast请求所在线程中, 在他们内部使用了<code>handler</code>,如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">&quot;SHOW: &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">  mHandler.post(mShow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* schedule handleHide into the right thread</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">&quot;HIDE: &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">  mHandler.post(mHide);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中, <code>mShow</code>, <code>mHide</code>是两个Runnable, 他们内部分别调用了<code>handleShow</code>和<code>handleHide</code>方法. 所以这两个方法才是真正完成隐藏和显示<code>Toast</code>的地方. </p>
<p><code>TN</code>的<strong>handleShow</strong>中会将<code>Toast</code>的视图添加到<code>Window</code>中.</p>
<p><code>TN</code>的<strong>handleHide</strong>中会将<code>Toast</code>的视图从<code>Window</code>中移除.</p>
<p>具体实现代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//handleShow()</span></span><br><span class="line"> mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line"> mWM.addView(mView, mParams);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//handleHide()</span></span><br><span class="line"><span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">&quot;REMOVE! &quot;</span> + mView + <span class="string">&quot; in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">     mWM.removeView(mView);</span><br><span class="line">  &#125;</span><br><span class="line">  mView = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code>Toast</code>流程已经完事.  除了说到的<code>Activity</code>, <code>Dialog</code>, <code>Toast</code>. 还有<code>PopupWindow</code><br>菜单栏, 状态栏都是通过<code>Window</code>来实现的. </p>
<blockquote>
<p>下一章: 第9章: 四大组件的工作过程</p>
</blockquote>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2016/08/16/《Android-开发艺术探索》-09-四大组件的工作过程/" data-toggle="tooltip" data-placement="top" title="《Android 开发艺术探索》 09-四大组件的工作过程">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2016/08/13/《Android-开发艺术探索》-07-Andriod动画深入分析/" data-toggle="tooltip" data-placement="top" title="《Android 开发艺术探索》 07-Andriod动画深入分析">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">文章目录</a>
                    </h5>
                    <ul class="catalog-body" style="padding-left: 0%; list-style:none;  width: 150%"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#android" title="android">android</a>
                        
                          <a class="tag" href="/tags/#笔记" title="笔记">笔记</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="#" target="_blank">Kaijun&#39;s Blog</a></li>
                    
                        <li><a href="#" target="_blank">Foo</a></li>
                    
                        <li><a href="#" target="_blank">Bar</a></li>
                    
                        <li><a href="#" target="_blank">Example Friends</a></li>
                    
                        <li><a href="#" target="_blank">It helps SEO</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "http-szysky-com";
    var disqus_identifier = "http://szysky.com/2016/08/15/%E3%80%8AAndroid-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B-08-%E7%90%86%E8%A7%A3Window%E5%92%8CWindowManager/";
    var disqus_url = "http://szysky.com/2016/08/15/%E3%80%8AAndroid-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B-08-%E7%90%86%E8%A7%A3Window%E5%92%8CWindowManager/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/szyskys">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/szysky">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/suzeyu1992">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://www.linkedin.com/in/szysky">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Szy&#39;sky Blog 2021
                    <br>
                    Theme by <a target="_blank" rel="noopener" href="http://huangxuan.me">Hux</a>
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span>
                    Ported by <a target="_blank" rel="noopener" href="http://blog.kaijun.rocks">Kaijun</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://szysky.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '5aca5df6308eba7bd10d5bac33225006';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>





<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>




<!-- Image to hack wechat -->
<img src="http://szysky.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
