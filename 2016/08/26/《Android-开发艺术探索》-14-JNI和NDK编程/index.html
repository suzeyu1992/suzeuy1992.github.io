<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="suzeyu skyszy`blog">
    <meta name="keyword"  content="suzeyu skyszy`blog">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          《Android 开发艺术探索》 14-JNI和NDK编程 - 筑梦 suzeyu`苏泽钰
        
    </title>

    <link rel="canonical" href="http://szysky.com/2016/08/26/《Android-开发艺术探索》-14-JNI和NDK编程/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/hux-blog.min.css">


    <!-- Pygments Github CSS -->
    
<link rel="stylesheet" href="/css/syntax.css">


    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Szy&#39;sky Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">

                 


                      <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','uaGE1nqtyiBMes6-h6b9','2.0.0');
</script>

                    




                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://szysky.com/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
    .h1_nav{font-size: 13px; padding-left:0%; color: #ff0000;}
    .h2_nav{font-size: 12px;padding-left: 4%;color: #ff0000; }
    .h3_nav{font-size: 11px;padding-left: 12%;}
    .h4_nav{font-size: 10px;padding-left: 18%;}
    .h5_nav{font-size: 9px;padding-left: 24%;}
    .h6_nav{font-size: 8px;padding-left: 30%;}


</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#android" title="android">android</a>
                        
                          <a class="tag" href="/tags/#笔记" title="笔记">笔记</a>
                        
                    </div>
                    <h1>《Android 开发艺术探索》 14-JNI和NDK编程</h1>
                    <h2 class="subheading">抄书笔记</h2>
                    <span class="meta">
                        Posted by Suzeyu on
                        2016-08-26
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <blockquote>
<p>第14章: 弥补Java的跨平台特性导致的于本地交互能力不足而出现的.</p>
</blockquote>
<p><strong>Java JNI</strong>本意为<code>Java Native Interface</code>(java本地接口), 是为方便java调用C或者C++等本地代码所封装的一层接口. 由于Java的跨平台性导致本地交互能力的不好, 一些和操作系统相关的特性Java无法完成, 于是Java提供了JNI专门用于和本地代码交互. </p>
<p><code>NDK</code>是android所提供的一个工具合集, 通过<code>NDK</code>可以在Android中更加方便地通过JNI来访问本地代码. <code>NDK</code>还提供了交叉编译工具, 开发人员只需要简单的修改<code>mk</code>文件就可以生成特定的CPU平台的动态库. 好处如下:</p>
<ol>
<li>提供代码的安全性. so库反编译比较困难</li>
<li>可以很方便地使用目前已有的C/C++开源库</li>
<li>提高程序在某些特定情形下得执行效率, 但是不能明显提高Android程序的的性能.</li>
</ol>
<h2 id="JNI的开发流程"><a href="#JNI的开发流程" class="headerlink" title="JNI的开发流程"></a>JNI的开发流程</h2><p>大体步骤就是在java中声明<code>native</code>方法, 然后调用c/c++实现的native的方法. 下面开始具体步骤</p>
<p><strong>1. 在Java中声明native方法</strong></p>
<p>创建一个java类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.szysky.note.androiddevseek_14;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNITest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;jni-test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String str)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span> </span>&#123;</span><br><span class="line">        JNITest jniTest = <span class="keyword">new</span> JNITest();</span><br><span class="line">        System.out.println(jniTest.get());</span><br><span class="line">        jniTest.set(<span class="string">&quot;java写入数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是<strong>通过静态代码块先加载so库</strong>, 然后声明两个<code>native</code>方法提供使用. 这两个方法需要在JNI中实现.   加载so库名称填入的虽然是<code>jni-test</code>, 但是so库全名称应该是<code>libjni-test.so</code>,这是加载so库的规范.</p>
<p><strong>2. 编辑Java源文件得到class文件, 然后通过javah命令导出JNI头文件</strong></p>
<p>在包的的根路径, 进行命令操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac com/szysky/note/androiddevseek_14/JNITest.java</span><br><span class="line">javah com.szysky.note.androiddevseek_14.JNITest</span><br></pre></td></tr></table></figure>
<p>执行之后会在, 操作的路径下生成一个<code>com_szysky_note_androiddevseek_14_JNITest.h</code>头文件, 这个就是第二步生成的东西. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line"><span class="comment">/* Header for class com_szysky_note_androiddevseek_14_JNITest */</span></span><br><span class="line"></span><br><span class="line">#ifndef _Included_com_szysky_note_androiddevseek_14_JNITest</span><br><span class="line">#define _Included_com_szysky_note_androiddevseek_14_JNITest</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">#endif</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_szysky_note_androiddevseek_14_JNITest</span></span><br><span class="line"><span class="comment"> * Method:    get</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_com_szysky_note_androiddevseek_114_JNITest_get</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jobject)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_szysky_note_androiddevseek_14_JNITest</span></span><br><span class="line"><span class="comment"> * Method:    set</span></span><br><span class="line"><span class="comment"> * Signature: (Ljava/lang/String;)V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_szysky_note_androiddevseek_114_JNITest_set</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jobject, jstring)</span></span>;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>对生成的<code>.h</code>文件进行一下说明:</p>
<ul>
<li><strong>函数名</strong>:格式遵循:<code>Java_包名_类名_方法名</code>包名之间的<code>.</code>分割全部替换成<code>_</code>分割.</li>
<li><strong>参数</strong>: <code>jstring</code>是代表String类型参数. 具体的类型关系后面会说明. </li>
<li><ul>
<li><strong><code>JNIEnv *</code></strong>: 表示一个指向JNI环境的指针, 可以通过它来访问JNI提供的方法.</li>
</ul>
</li>
<li><ul>
<li><strong><code>jobject</code></strong>: 表示java对象中的this.</li>
</ul>
</li>
<li><ul>
<li><strong><code>JNIEXPORT</code>和<code>JNICALL</code></strong>: 这是JNI种所定义的宏, 可以在<code>jni.h</code>这个头文件查到</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>而这个宏定义是必须的, 作用是<strong>指定extern”C”内部的函数采用C语言的命名风格来编译</strong>. 如果设定那么当JNI采用<code>C++</code>来实现时, 由于<code>C/C++</code>编译过程对函数的命名风格不同, 这将导致JNI在链接时无法根据函数名找到具体的函数, 那么JNI调用肯定会失效. </p>
<p><strong>3. 实现JNI方法</strong></p>
<p><code>JNI</code>方法是指的Java中声明的<code>native</code>方法, 这里可以选择c++和c来实现. 过程都是类似的. 只有少量的区别, 这里两种都实现一下.</p>
<p>首先是<code>C++</code></p>
<p>在工程的主目录创建一个子目录, 名称任意, 然后将之前通过<code>javah命令</code>生成的**.h头文件**复制到创建的目录下, 接着创建<code>test.cpp</code>实现如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Created by 苏泽钰 on 16/8/27.</span></span><br><span class="line"><span class="comment">// test.app</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;com_szysky_note_androiddevseek_14_JNITest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_com_szysky_note_androiddevseek_114_JNITest_get</span><span class="params">(JNIEnv *env, jobject thiz)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行在c++文件中 get方法\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;Hello from JNI .&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_szysky_note_androiddevseek_114_JNITest_get</span><span class="params">(JNIEnv *env, jobject thiz, jstring string)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行在c++文件中 set方法\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span>* str = (<span class="keyword">char</span>*) env-&gt;<span class="built_in">GetStringUTFChars</span>(string, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n, str&quot;</span>);</span><br><span class="line"></span><br><span class="line">    env-&gt;<span class="built_in">ReleaseStringUTFChars</span>(string, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在看一下<code>C</code>的实现:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Created by 苏泽钰 on 16/8/27.</span></span><br><span class="line"><span class="comment">// test.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;com_szysky_note_androiddevseek_14_JNITest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_com_szysky_note_androiddevseek_114_JNITest_get</span><span class="params">(JNIEnv *env, jobject thiz)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行在c文件中 get方法\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(<span class="string">&quot;Hello from JNI .&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_szysky_note_androiddevseek_114_JNITest_get</span><span class="params">(JNIEnv *env, jobject thiz, jstring <span class="built_in">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行在c文件中 set方法\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span>* str = (<span class="keyword">char</span>*) (*env)-&gt;GetStringUTFChars(env, <span class="built_in">string</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n, str&quot;</span>);</span><br><span class="line"></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, <span class="built_in">string</span>, str);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>其实<code>C\C++</code>在实现上很相似, 但是对于<code>env</code>的操作方式有所不同. </p>
<p><strong>4. 编写so库并在java中调用</strong></p>
<p>so库的编译这里采用<code>gcc</code>(Linux, mac环境下, window不清楚). 命令cd到放置刚才生成c/c++的目录下. </p>
<p>使用如下命令:<br><code>gcc -shared -I /Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/include -fPIC test.cpp -o libjni-test.so</code></p>
<p><strong>Linux</strong></p>
<p><strong>/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk</strong>这个就是java的环境目录. 书上这条操作是在<code>Linux</code>,<strong>如果你是mac系统, 请这样修改一下,要不无法编译</strong></p>
<p><strong>Mac</strong></p>
<p>首先找到你的Java环境的目录然后在后面追加<code>Content/Home/</code>来替换上面的路径. 这么做的意义可以上mac电脑下看一下<code>/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/include</code>发现文件夹下有有一个<code>jni.h</code>的文件, 这个文件在我们生成的头文件中有过导入, 这下明白了为什么修改了吧, 别急还有一步, 在<code>jni.h</code>中还会导入一个<code>jni_md.h</code>这个文件默认在<code>jni.h的同级目录有一个darwin文件夹下</code>把这个文件也拷贝出来放在和<code>jni.h</code>同级,  然后执行下面命令:</p>
<p><code>gcc -shared -I /Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/include -fPIC test.cpp -o libjni-test.jnilib</code></p>
<p>(别忘了替换路径)</p>
<p>如果是mac系统, 那么生成<code>.jnilib</code>而不是<code>.so</code>.  不然生成了so在通过java命令执行的时候会抛出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.UnsatisfiedLinkError: no jni-test in java.library.path</span><br><span class="line">	at java.lang.ClassLoader.loadLibrary(ClassLoader.java:<span class="number">1867</span>)</span><br><span class="line">	at java.lang.Runtime.loadLibrary0(Runtime.java:<span class="number">870</span>)</span><br><span class="line">	at java.lang.System.loadLibrary(System.java:<span class="number">1122</span>)</span><br><span class="line">	at com.szysky.note.androiddevseek_14.JNITest.&lt;clinit&gt;(JNITest.java:<span class="number">15</span>)</span><br><span class="line">	at java.lang.Class.forName0(Native Method)</span><br><span class="line">	at java.lang.Class.forName(Class.java:<span class="number">264</span>)</span><br><span class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">122</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="generate_so.png"></p>
<p>然后库已经生成完了, 我们就检测一下吧.  这里使用<code>Java命令</code>执行, 因为需要指定库路径, 回到包的根目录</p>
<p><code>java -Djava.library.path=jni  com.szysky.note.androiddevseek_14.JNITest</code></p>
<p>看一下输出结果:</p>
<p><img src="jni_result.png"></p>
<p>ok, 关于JNI的java调用c/c++代码, 简单的演示了</p>
<h2 id="NDK的开发流程"><a href="#NDK的开发流程" class="headerlink" title="NDK的开发流程"></a>NDK的开发流程</h2><p><code>NDK</code>的开发是基于<code>JNI</code>的, 主要有如下步骤</p>
<p><strong>1. 下载并进行配置NDK</strong></p>
<p>首先要下载NDK. <a target="_blank" rel="noopener" href="https://developer.android.com/ndk/downloads/index.html">NDK下载地址</a> 下载后解压.   或者你可以直接在<code>Android SDK Manager</code>下载. </p>
<p><img src="ndk_download.png"></p>
<p>如果在<code>sdk manager</code>下载那么就在上面图中上部的<code>Android SDK Location</code>指定根目录下的<code>ndk-bundle</code>文件夹. </p>
<p>接下来就配置一下全局环境, 这里是<strong>mac系统</strong>下的操作(Linux修改~/.bashrc文件), 命令行直接输出:</p>
<p><code>open ~/.bash_profile</code> 添加一下配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 设置ndk环境路径</span><br><span class="line">export PATH=$&#123;PATH&#125;:/Users/suzeyu/Library/Android/sdk/ndk-bundle</span><br></pre></td></tr></table></figure>
<p>可以使用<code>ndk-build</code>检测是否成功了, 之后就可以使用<code>ndk-build</code>命令产生编译so的库. 这里使用的NDK版本是<code>android-ndk-r12d</code></p>
<p><strong>2. 创建一个android项目, 在类中声明所需的native方法</strong></p>
<p>这一步和上面创建java普通类的方法一样.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;jni-test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>3. 实现Android项目中所声明的native方法</strong></p>
<p><strong>jniLibs</strong>是<strong>AndroidStudio</strong>默认目录，用来存放已经编译好的.so文件，当然你也可以放在任意自定义目录下，例如src/main/libs，然后在build.gradle中指定相应的资源目录位置即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets.main &#123;</span><br><span class="line">        // 你的.so库的实际路径</span><br><span class="line">        jniLibs.srcDir &#x27;src/main/libs&#x27; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是已经有了<strong>so文件</strong>的方式. 下面说说如果只有**c/c++**源码</p>
<p><strong>这里有两种实现一种是手动使用<code>ndk-build</code>的命令, 一种利用<code>gradle</code></strong></p>
<hr>
<p><strong>利用gradle来生成</strong></p>
<p>这里书上的方法已经不适用, 上网查询了一下是因为<code>gradle</code>文件首行使用的插件<code>apply plugin: &#39;com.android.application&#39;</code>导致</p>
<hr>
<p><strong>使用传统的<code>ndk-build</code>来实现吧</strong></p>
<p>在<code>jni</code>下创建3个文件, <code>test.cpp</code>, <code>Android.mk</code>, <code>Application.mk</code>三个文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是test.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function">jstring  <span class="title">Java_com_szysky_note_androiddevseek_114_MainActivity_get</span><span class="params">(JNIEnv *env, jobject thiz)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行在c++文件中 get方法\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;Hello from JNI .&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span>  <span class="title">Java_com_szysky_note_androiddevseek_114_MainActivity_set</span><span class="params">(JNIEnv *env, jobject thiz, jstring string)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行在c++文件中 set方法\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span>* str = (<span class="keyword">char</span>*) env-&gt;<span class="built_in">GetStringUTFChars</span>(string, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    env-&gt;<span class="built_in">ReleaseStringUTFChars</span>(string, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Android.mk文件</span></span><br><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := jni-test    <span class="comment">//生成so的文件名称</span></span><br><span class="line">LOCAL_SRC_FILES := test.cpp <span class="comment">//所关联的cpp文件</span></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Application.mk文件</span></span><br><span class="line">APP_ABI := armeabi</span><br></pre></td></tr></table></figure>

<p>这里说明一个<code>mk</code>文件:</p>
<ul>
<li><code>LOCAL_MODULE:</code> 表示模块的名称</li>
<li><code>LOCAL_SRC_FILES:</code> 表示需要参与的源文件</li>
<li><code>APP_ABI:</code> 表示CPU的架构平台类型. 如<code>armeabi</code>, <code>x86</code>, <code>mips</code>等.</li>
</ul>
<p>而<code>test.cpp</code>这个文件</p>
<p>要注意这里的函数名换成再调用处的所在类,  按照生成的JNI的函数的命名规则. </p>
<p><strong>4. 切换到jni目录的父目录下, 通过<code>ndk-build</code>命令编译产生so库</strong></p>
<p>命令行截图:</p>
<p><img src="cmd_result.png"></p>
<p>这些做完了, 使用命令生成. 如下图:</p>
<p><img src="ndk_build_result.png"></p>
<p>在产生的<code>libs</code>目录下把生成的<code>so</code>文件放在<code>Android Studio的默认so路径下 Main/jniLibs</code>文件夹下.  <strong>我在测试的时候, 必须要把<code>jni</code>文件夹内容删掉,否则会报错, 按照错误提示应该也可以通过gradle来在运行时候忽略此文件</strong></p>
<p>为了保留生成必须代码而不影响运行, 原<code>jni</code>内容被移动到<code>backup</code>文件夹中.</p>
<h2 id="JNI的数据类型和类型签名"><a href="#JNI的数据类型和类型签名" class="headerlink" title="JNI的数据类型和类型签名"></a>JNI的数据类型和类型签名</h2><p><code>JNI</code>的数据类型包含两种: 基本类型和引用类型.</p>
<p>基本类型主要有<code>jboolean</code>, <code>jchar</code>, <code>jint</code>等, 和Java中的数据类型对应如下:</p>
<table>
<thead>
<tr>
<th>JNI类型</th>
<th>Java类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>jboolean</td>
<td>boolean</td>
<td>无符号8位整型</td>
</tr>
<tr>
<td>jbyte</td>
<td>byte</td>
<td>无符号8位整型</td>
</tr>
<tr>
<td>jchar</td>
<td>char</td>
<td>无符号16位整型</td>
</tr>
<tr>
<td>jshort</td>
<td>short</td>
<td>有符号16位整型</td>
</tr>
<tr>
<td>jint</td>
<td>int</td>
<td>32位整型</td>
</tr>
<tr>
<td>jlong</td>
<td>long</td>
<td>64位整型</td>
</tr>
<tr>
<td>jfloat</td>
<td>float</td>
<td>32位浮点型</td>
</tr>
<tr>
<td>jdouble</td>
<td>double</td>
<td>64位浮点型</td>
</tr>
<tr>
<td>void</td>
<td>void</td>
<td>无类型</td>
</tr>
</tbody></table>
<p><code>JNI</code>中的引用类型主要有<strong>类</strong>, <strong>对象</strong>和<strong>数组</strong>. 他们和Java中的引用类型的对应关系如下:</p>
<table>
<thead>
<tr>
<th>JNI类型</th>
<th>Java类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>jobject</td>
<td>Object</td>
<td>Object类型</td>
</tr>
<tr>
<td>jclass</td>
<td>Class</td>
<td>Class类型</td>
</tr>
<tr>
<td>jstring</td>
<td>String</td>
<td>String类型</td>
</tr>
<tr>
<td>jobjeckArray</td>
<td>Object[]</td>
<td>对象数组</td>
</tr>
<tr>
<td>jbooleanArray</td>
<td>boolean[]</td>
<td>boolean数组</td>
</tr>
<tr>
<td>jbyteArray</td>
<td>byte[]</td>
<td>byte数组</td>
</tr>
<tr>
<td>jcharArray</td>
<td>char[]</td>
<td>char数组</td>
</tr>
<tr>
<td>jshortArray</td>
<td>short[]</td>
<td>short数组</td>
</tr>
<tr>
<td>jintArray</td>
<td>int[]</td>
<td>int数组</td>
</tr>
<tr>
<td>jlongArray</td>
<td>long[]</td>
<td>long数组</td>
</tr>
<tr>
<td>jfloatArray</td>
<td>float[]</td>
<td>float数组</td>
</tr>
<tr>
<td>jdoubleArray</td>
<td>double[]</td>
<td>double数组</td>
</tr>
<tr>
<td>jthrowable</td>
<td>Throwable</td>
<td>Throwable</td>
</tr>
</tbody></table>
<p><code>JNI</code>的类型签名标识了一个特定的Java类型, 这个类型既可以是类也可以是方法, 也可以是数据类型.</p>
<p>类的签名比较简单, 它采用<code>L+包名+类型+;</code>的形式, 只需要将其中的<code>.</code>替换为<code>/</code>即可. 例如<code>java.lang.String</code>, 它的签名为<code>Ljava/lang/String;</code>, 末尾的<code>;</code>也是一部分.</p>
<p>基本数据类型的签名采用一系列大写字母来表示, 如下:</p>
<table>
<thead>
<tr>
<th>Java类型</th>
<th>签名</th>
<th>Java类型</th>
<th>签名</th>
<th>Java类型</th>
<th>签名</th>
</tr>
</thead>
<tbody><tr>
<td><strong>boolean</strong></td>
<td>Z</td>
<td><strong>byte</strong></td>
<td>B</td>
<td><strong>char</strong></td>
<td>C</td>
</tr>
<tr>
<td><strong>short</strong></td>
<td>S</td>
<td><strong>int</strong></td>
<td>I</td>
<td><strong>long</strong></td>
<td>J</td>
</tr>
<tr>
<td><strong>float</strong></td>
<td>F</td>
<td><strong>double</strong></td>
<td>D</td>
<td><strong>void</strong></td>
<td>V</td>
</tr>
</tbody></table>
<p>基本数据类型的签名基本都是单词的首字母, 但是boolean除外因为B已经被<code>byte</code>占用, 而long的表示也被<code>Java类签名</code>占用. 所以不同. </p>
<p>而对象和数组, <strong>对象的签名</strong>就是对象所属的类签名, <strong>数组</strong>的签名<code>[+类型签名</code>例如byte数组. 首先类型为<code>byte</code>,所以签名为<code>B</code>然后因为是数组那么最终形成的签名就是<code>[B</code>.例如如下各种对应:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char[]      [C</span><br><span class="line">float[]     [F</span><br><span class="line">double[]    [D</span><br><span class="line">long[]      [J</span><br><span class="line">String[]    [Ljava/lang/String;</span><br><span class="line">Object[]    [Ljava/lang/Object;</span><br></pre></td></tr></table></figure>

<p>如果是多维数组那么就根据数组的维度多少来决定<code>[</code>的多少, 例如<code>int[][]</code>那么就是<code>[[I</code></p>
<p>方法的签名为**(参数类型签名)+返回值类型签名**. </p>
<p>举个例子有这个一个方法<code>boolean fun(int a, double b, int[] c)</code>. 参数类型的签名是连在一起, 那么按照方法的签名规则就是<code>(ID[I)Z</code></p>
<p>例如方法:<code>void fun(int a, String s, int[] c)</code>, 那么签名就是<code>(ILjava/lang/String;[I)V</code></p>
<p>例如方法:<code>int fun()</code>, 对应签名<code>()I</code></p>
<p>例如方法:<code>int fun(float f)</code>, 对应签名<code>(F)I</code></p>
<h2 id="JNI调用Java方法的流程"><a href="#JNI调用Java方法的流程" class="headerlink" title="JNI调用Java方法的流程"></a>JNI调用Java方法的流程</h2><blockquote>
<p>JNI调用java方法的流程是先通过类名找到类, 然后在根据方法名找到方法的id, 最后就可以调用这个方法了. 如果是调用Java的非静态方法, 那么需要构造出类的对象后才可以调用它</p>
</blockquote>
<p>演示一下调用静态的方法:</p>
<ol>
<li>首先在java中声明要被调用的静态方法. 这里触发的时机是一个按钮的点击,自行添加</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">static</span>&#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;jni-test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个静态方法 , 提供给JNI调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodCalledByJni</span><span class="params">(String fromJni)</span></span>&#123;</span><br><span class="line">    Log.e(<span class="string">&quot;susu&quot;</span>, <span class="string">&quot;我是从JNI被调用的消息,  JNI返回的值是:&quot;</span>+fromJni );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义调用本地方法, 好让本地方法回调java中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">callJNIConvertJavaMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (view.getId())&#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.btn_jni2java:</span><br><span class="line">            <span class="comment">// 调用JNI的方法</span></span><br><span class="line">            callJNIConvertJavaMethod();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在JNI的<code>test.cpp</code>中添加一个c的函数用来处理调用java的逻辑, 并提供一个方法供java代码调起来触发. 一个两个方法.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义调用java中的方法的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callJavaMethod</span><span class="params">( JNIEnv *env, jobject thiz)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 先找到要调用的类</span></span><br><span class="line">    jclass clazz = env -&gt; <span class="built_in">FindClass</span>(<span class="string">&quot;com/szysky/note/androiddevseek_14/MainActivity&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找不到要调用方法的所属类&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取java方法id</span></span><br><span class="line">    <span class="comment">// 参数二是调用的方法名,  参数三是方法的签名</span></span><br><span class="line">    jmethodID id = env -&gt; <span class="built_in">GetStaticMethodID</span>(clazz, <span class="string">&quot;methodCalledByJni&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找不到要调用方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jstring msg = env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;我是在c中生成的字符串&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始调用java中的静态方法</span></span><br><span class="line">    env -&gt; <span class="built_in">CallStaticVoidMethod</span>(clazz, id, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Java_com_szysky_note_androiddevseek_114_MainActivity_callJNIConvertJavaMethod</span><span class="params">(JNIEnv *env, jobject thiz)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用c代码成功, 马上回调java中的代码&quot;</span>);</span><br><span class="line">    <span class="built_in">callJavaMethod</span>(env, thiz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>稍微说明一下, 程序首先根据类名<code>com/szysky/note/androiddevseek_14/MainActivity</code>找到类, 然后在根据方法名<code>methodCalledByJni</code>找到方法, 并传入方法对应签名<code>(Ljava/lang/String;)V</code>, 最后通过<code>JNIEnv</code>对象的<code>CallStaticVoidMethod()</code>方法来完成最终调用.</p>
<p>最后只要在<code>Java_com_szysky_note_androiddevseek_114_MainActivity_callJNIConvertJavaMethod</code>方法中调用<code>callJavaMethod</code>方法即可.</p>
<p>流程就是–&gt; 按钮触发了点击的<code>onClikc</code> –&gt; 然后Java中会调用JNI的<code>callJNIConvertJavaMethod()</code> –&gt; JNI的<code>callJNIConvertJavaMethod()</code>方法内部会调用具体实现回调Java中的方法<code>callJavaMethod()</code> –&gt; 方法最终通过<code>CallStaticVoidMethod()</code>调用了Java中的<code>methodCalledByJni()</code>来接收一个参数并打印一个log.</p>
<p>结果图:</p>
<p><img src="JNIcallJava.png"></p>
<p>生成<code>so库</code>的文件保存在git中的<code>app/src/main/backup</code>目录下一个两个版本代码, 第一个就是第二小节中的NDK开发代码, 第二个就是第四小节的代码就是目前的. 而<code>so库</code>是最新的, 包含了所有的JNI代码生成的库文件.</p>
<p><code>JNI</code>调用<code>Java</code>的过程和Java中方法的定义有很大关联, 针对不同类型的java方法, <code>JNIEnv</code>提供了不同的接口去调用, 更为细节的部分要去开发中或者去网站去了解更多.</p>
<blockquote>
<p>第15章 Android的性能优化</p>
</blockquote>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2016/08/27/《Android-开发艺术探索》-15-Android性能优化/" data-toggle="tooltip" data-placement="top" title="《Android 开发艺术探索》 15-Android性能优化">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2016/08/25/《Android-开发艺术探索》-13-综合技术/" data-toggle="tooltip" data-placement="top" title="《Android 开发艺术探索》 13-综合技术">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">文章目录</a>
                    </h5>
                    <ul class="catalog-body" style="padding-left: 0%; list-style:none;  width: 150%"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#android" title="android">android</a>
                        
                          <a class="tag" href="/tags/#笔记" title="笔记">笔记</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="#" target="_blank">Kaijun&#39;s Blog</a></li>
                    
                        <li><a href="#" target="_blank">Foo</a></li>
                    
                        <li><a href="#" target="_blank">Bar</a></li>
                    
                        <li><a href="#" target="_blank">Example Friends</a></li>
                    
                        <li><a href="#" target="_blank">It helps SEO</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "http-szysky-com";
    var disqus_identifier = "http://szysky.com/2016/08/26/%E3%80%8AAndroid-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B-14-JNI%E5%92%8CNDK%E7%BC%96%E7%A8%8B/";
    var disqus_url = "http://szysky.com/2016/08/26/%E3%80%8AAndroid-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B-14-JNI%E5%92%8CNDK%E7%BC%96%E7%A8%8B/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/szyskys">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/szysky">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/suzeyu1992">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://www.linkedin.com/in/szysky">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Szy&#39;sky Blog 2021
                    <br>
                    Theme by <a target="_blank" rel="noopener" href="http://huangxuan.me">Hux</a>
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span>
                    Ported by <a target="_blank" rel="noopener" href="http://blog.kaijun.rocks">Kaijun</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://szysky.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '5aca5df6308eba7bd10d5bac33225006';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>





<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>




<!-- Image to hack wechat -->
<img src="http://szysky.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
