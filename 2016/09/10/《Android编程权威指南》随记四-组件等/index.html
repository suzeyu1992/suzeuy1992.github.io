<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="suzeyu skyszy`blog">
    <meta name="keyword"  content="suzeyu skyszy`blog">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          《Android编程权威指南》随记四 组件等 - 筑梦 suzeyu`苏泽钰
        
    </title>

    <link rel="canonical" href="http://szysky.com/2016/09/10/《Android编程权威指南》随记四-组件等/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/hux-blog.min.css">


    <!-- Pygments Github CSS -->
    
<link rel="stylesheet" href="/css/syntax.css">


    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Szy&#39;sky Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">

                 


                      <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','uaGE1nqtyiBMes6-h6b9','2.0.0');
</script>

                    




                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://szysky.com/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
    .h1_nav{font-size: 13px; padding-left:0%; color: #ff0000;}
    .h2_nav{font-size: 12px;padding-left: 4%;color: #ff0000; }
    .h3_nav{font-size: 11px;padding-left: 12%;}
    .h4_nav{font-size: 10px;padding-left: 18%;}
    .h5_nav{font-size: 9px;padding-left: 24%;}
    .h6_nav{font-size: 8px;padding-left: 30%;}


</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#android" title="android">android</a>
                        
                          <a class="tag" href="/tags/#笔记" title="笔记">笔记</a>
                        
                    </div>
                    <h1>《Android编程权威指南》随记四 组件等</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by Suzeyu on
                        2016-09-10
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <blockquote>
<p>这本书属于入门, 有很多内容可以当做扩展来了解一些API, 并且有的时候可以适当的利用Google提供好的API来做一些高效开发节约时间成本. 原理东西本书偏少. 可以学习本书中的代码的编写风格, 书中代码都是采用<strong>MVC</strong>模型来编写的. 就写这么多, 下面开始整理一些小知识点.</p>
</blockquote>
<h2 id="Message与Message-Handler"><a href="#Message与Message-Handler" class="headerlink" title="Message与Message Handler"></a>Message与Message Handler</h2><p><strong>消息Message</strong></p>
<p>消息是<code>Message</code>类的一个实例. 包含好几个实例变量. 其中有三个需要在实现时定义. </p>
<ul>
<li><code>what</code> 用户定义的int类型消息代码, 用来描述消息</li>
<li><code>obj</code> 随消息发送的用户指定对象</li>
<li><code>target</code> 处理消息的<code>Handler</code></li>
</ul>
<p>Message的目标是Handler类的一个实例. <code>Message</code>在创建时, 会自动与一个<code>Handler</code>相关联. Message在准备处理状态下, Handler是负责让消息处理行为发生的对象. </p>
<p><strong>Handler</strong></p>
<p>要处理消息以及消息指定的任务, 首先需要一个消息<code>Handler</code>实例. <code>Handler</code>不仅仅是处理<code>Message</code>的目标(target), 也是创建和发出<code>Message</code>的接口. </p>
<p><code>Looper</code> 拥有<code>Message</code>对象的收件箱, 所以<code>Message</code>必须在<code>Looper</code>上发布或读取. 基于<code>Looper</code>和<code>Message</code>的这种关系, 为了与<code>Looper</code>协同工作, <code>Handler</code>总是引用着它.</p>
<ul>
<li>一个<code>Handler</code>仅于一个<code>Looper</code>相关联. </li>
<li>一个<code>Message</code>也仅于一个目标<code>Handler</code>相关联</li>
<li>多个<code>Handler</code>可能都关联一个<code>Looper</code>(这也意味着一个<code>Handler</code>的<code>Message</code>可能与另一个<code>Handler</code>的<code>Message</code>存在在同一个消息队列中)</li>
<li><code>Looper</code>拥有整个队列</li>
</ul>
<p><strong>Handler的使用</strong></p>
<p>消息的目标<code>Handler</code>通常不需要手动设置. 一个比较理想的方式是调用<code>Handler.obtainMessage()</code>方法创建消息并传入其他消息字段, 然后该方法自动完成目标<code>Handler</code>的设置. </p>
<p>为避免创建新的<code>Message</code>对象, <code>Handler.obtainMessage()</code>方法会从公共循环池里获取消息. 因此相比重新创建, 这种复用的选择会更加高效. </p>
<p>一旦取得了<code>Message</code>就可以调用<code>sendToTarget()</code>方法将其发送给它的<code>Handler</code>. 然后<code>Handler</code>会将<code>Message</code>放置在<code>Looper</code>消息队列的尾部. </p>
<p><code>Looper</code>取得到消息队列中的特定消息后, 会将它发送给消息目标去处理. 消息一般是在目标的<code>Handler.handleMessage()</code>中进行处理的. </p>
<p><strong>传递Handler</strong></p>
<p><code>HandlerThread</code>能在主线程上完成任务的一种方式是, 让主线程将其自身的<code>Handler</code>传递给<code>HandlerThread</code>. </p>
<p>主线程是一个拥有<code>Handler</code>和<code>Looper</code>的消息循环. 主线程上创建的<code>handler</code>会自动与它的<code>Looper</code>相关联. 可以将主线程的<code>handler</code>传递给另一个线程. 传递出去的<code>Handler</code>与创建线程的<code>Looper</code>始终保持着联系. 因此任何已传出的<code>Handler</code>负责处理的消息都将在主线程的消息队列中处理. </p>
<p><strong>关于AsyncTask</strong></p>
<p> <code>AsyncTask</code> 主要应用于那些短暂且较少重复的任务.  并且在<code>Android 3.2</code>时其内部进行了代码的改动. 改动之后的效果是<code>AsyncTask</code>不再为每一个<code>AsyncTask</code>的实例单独创建一个线程. 相反, 它使用了<code>Executor</code>在单一的后台线程上运行所有的<code>AsyncTask</code>的后台任务. 这意味着每个<code>AsyncTask</code>都需要排队逐个运行.  (虽然可以通过特定的方法改变其内部的顺序调用, 但是或许应该想想是否有其他的更好的方式来选择)</p>
<h2 id="启动模式于新的Intent"><a href="#启动模式于新的Intent" class="headerlink" title="启动模式于新的Intent"></a>启动模式于新的Intent</h2><p>启动模式决定了<code>activity</code>在收到新的<code>intent</code>时的启动方式. </p>
<table>
<thead>
<tr>
<th>启动模式</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>standard</td>
<td>默认行为, 针对每一个收到的新Intent, 都会启动新的activity</td>
</tr>
<tr>
<td>singleTop</td>
<td>如果activity实例已经处在回退栈的顶部, 则不重新创建新的activity, 而直接路由新的intent给现有的activity</td>
</tr>
<tr>
<td>singleTask</td>
<td>在自身task中启动activity, 如果task中activity已经存在, 则清除回退站中该activity上的任何activity, 然后路由新的intent给现有的activity</td>
</tr>
<tr>
<td>singleInstance</td>
<td>在自身task中启动activity, 该activity是task中唯一的activity, 如果任何其他activity从该task中启动, 他们都将启动到自己的task中. 如果task中的activity已经存在. 那么就路由新的intent给现有的activity</td>
</tr>
</tbody></table>
<p>上面说到路由新的<code>intent</code>给现有的<code>activity</code>. 这个新的<code>intent</code>通过复写<code>activity#onNewIntent()</code>可以获得. </p>
<h2 id="使用SP实现轻量级数据存储"><a href="#使用SP实现轻量级数据存储" class="headerlink" title="使用SP实现轻量级数据存储"></a>使用SP实现轻量级数据存储</h2><p>对于存储可以采用序列化对象并保存至外部存储设备的方式, 实现持久化存储. 然后对于<strong>轻量级数据的持久化</strong>可以使用<code>shared preferences</code>会更加简单高效. </p>
<p><code>shared preferences</code>本质上就是文件系统中的文件. 可使用<code>SharedPreferences</code>类对其进行读写. <code>SharedPreferences</code>实例使用起来更像一个键值对仓库如<code>Bundle</code>, 但它可以通过持久化存储保存数据. 键值对中的键为<strong>字符串</strong>. 而值是<strong>原子数据类型</strong>. 其本质上就是一种简单的XML文件. 但<code>SharedPreferences</code>类已屏蔽了读写文件的实现细节. </p>
<p><strong>关于使用:</strong>   可以使用<code>Context.getSharePreferences(String, int)</code>方法. 然而在实际开发中, 由于<code>sharedpreferences</code>共享整个应用. 并不太关心获取的特定实例是什么. 这种情况下, 可以使用<code>PreferenceManager.getDefaultSharedPreferences(Context)</code>, 该方法会返回具有私有权限与默认名称的实例. </p>
<p>而对于添加数据, 通过SP对象的<code>edit()</code>方法可以获得一个<code>Editor</code>实例, 通过这个实例, 就可将一组数据操作放入一个事务中, 添加之后. 通过<code>Editor.commit()</code>最终写入数据. </p>
<h2 id="后台服务"><a href="#后台服务" class="headerlink" title="后台服务"></a>后台服务</h2><p><strong>IntentService</strong></p>
<p><code>IntentService</code>并不是<code>Android</code>提供唯一服务, 但却是最常用的. <code>IntentService</code>也是一个<code>Content</code>. 并能够响应intent.  服务的<code>intent</code>又称作<strong>命令</strong>. 每一条命令都要求服务完成某项具体的任务. </p>
<p><code>IntentService</code>逐个执行命令队列的命令. 接收到首个命令时, <code>IntentService</code>即完成启动, 并触发一个后台线程, 然后将命令放入队列. </p>
<p>随后<code>IntentService</code>继续按顺序执行每一条命令, 并同时为每一条命令在后台线程上调用<code>onHandlerIntent()</code>方法. 新进命令总是放置在队列尾部. 最后, 执行完队列中全部命令后, 服务也随即停止并被销毁. </p>
<h2 id="AlarmManager延迟运行服务"><a href="#AlarmManager延迟运行服务" class="headerlink" title="AlarmManager延迟运行服务"></a>AlarmManager延迟运行服务</h2><p>有时为了保证服务在后台的可用, 当没有<code>activity</code>在运行时, 需通过某种方式在后台执行一些任务. 比如说, 设置一个5分钟间隔的定时器. </p>
<p>一种实现方式是调用<code>Handler</code>的<code>sendMessageDelayed()</code>或者<code>postDelayed()</code>方法. 但如果用户离开了当前应用. 进程就会停止, <code>Handler</code>消息也会随之消亡, 因此该解决方案并不算可靠. </p>
<p>这样可以尝试使用<code>AlarmManager</code>. <code>AlarmManager</code>是可以发送<code>Intent</code>的<strong>系统服务</strong>. 那么如何告诉<code>AlarmManager</code>发送<code>Intent</code>呢? 使用<code>PendingIntent</code>. 利用<code>PendingIntent</code>打包<code>Intent</code>, 然后将其发送给系统中的其他部件, 如<code>AlarmManager</code>. 如下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setServiceAlarm</span><span class="params">(Context context, <span class="keyword">boolean</span> isOpen)</span></span>&#123;</span><br><span class="line">   Intent intent = <span class="keyword">new</span> Intent(context, 要打开服务的类名.class);</span><br><span class="line"></span><br><span class="line">   PendingIntent pi = PendingIntent.getService(context, <span class="number">0</span>, intent, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (isOpen)&#123;</span><br><span class="line">       <span class="comment">// 设置定时器</span></span><br><span class="line">       alarmManager.setRepeating(AlarmManager.RTC, System.currentTimeMillis(), <span class="number">1000</span> * <span class="number">15</span> , pi);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       alarmManager.cancel(pi);</span><br><span class="line">       pi.cancel();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码中只要替换创建<code>Intent</code>指定的服务类名. 那么当调用了<code>setServiceAlarm</code>传递<code>true</code>那么. 会发现每隔15秒就会启动一次<code>IntentService</code>. 即使进程停止, <code>AlarmManager</code>依然会不断发送<code>intent</code>. 以反复启动服务. </p>
<h2 id="PendingIntent"><a href="#PendingIntent" class="headerlink" title="PendingIntent"></a>PendingIntent</h2><p><code>PendingIntent</code>是一种<strong>token</strong>对象. 调用<code>PendingIntentn.getService()</code>方法获取<code>PendingIntent</code>时, 我们告诉操作系统: 要使用<code>startService()</code>方法发送这个<code>intent</code>. 随后调用<code>PendingIntent</code>对象的<code>send()</code>方法时, 操作系统会按照我们的要求发送原来封装的<code>Intent</code>.</p>
<p><code>PendingIntent</code>真正精妙之处在于, 将<code>PendingIntent</code>交给其他应用使用时, 它是代表当前应用发送<code>token</code>对象的. 另外<code>PendingIntent</code>本身存在于操作系统而不是<code>token</code>里, 因此实际上是我们在控制着它. 如果不顾及别人的感受, 也可以在交给别人一个<code>PendingIntent</code>对象后, 立即撤销它, 让send()方法什么也不做. </p>
<p>如果使用同一个<code>intent</code>请求<code>PendingIntent</code>两次, 得到的<code>PendingIntent</code>仍会是同一个, 我们可借此测试某个<code>PendingIntent</code>是否已存在, 或撤销已发出的<code>PendingIntent</code></p>
<p><strong>使用<code>PendingIntent</code>管理定时器</strong></p>
<p>一个<code>PendingIntent</code>只能登记一个定时器, 可以通过<code>AlarmManager.cancel(PendingIntent)</code>方法来撤销<code>PendingIntent</code>的定时器, 然后撤销<code>PendingIntent</code>. </p>
<p>还有一种方式可以判断定时器激活与否, 既然撤销定时器也随即撤销了<code>PendingIntent</code>, 可通过检查<code>PendingIntent</code>是否存在, 来确认定时器是否激活. 具体实现, 传入<code>PendingIntent.FLAG_NO_CREATE</code>标记给<code>PendingIntent.getService()</code>方法即可, 该标记表示如果<code>PendingIntent</code>不存在则返回null. </p>
<h2 id="通知消息-Notification"><a href="#通知消息-Notification" class="headerlink" title="通知消息 Notification"></a>通知消息 Notification</h2><p>如果服务需要与用户进行信息沟通, **通知消息(notification)**是一个不错的选择, 通知消息是指显示在通知抽屉上的消息条目, 用户可向下滑动屏幕读取. </p>
<p>发送通知消息, 首先需要创建一个<code>Notification</code>对象. <code>notification</code>需要使用构造对象完成创建.</p>
<p>一个比较完成的<code>Notification</code>应该具备如下:</p>
<ul>
<li>首次显示通知消息时, 在状态栏上显示的ticker text.</li>
<li>ticker text消失后, 在状态栏上显示的图标</li>
<li>代表通知信息自身, 在通知抽屉中显示的视图</li>
<li>用户点击抽屉中的通知信息, 触发<code>PendingIntent</code></li>
</ul>
<p>完成<code>Notification</code>对象的创建后, 可调用<code>Notification</code>系统服务的<code>notify(int,Notification)</code>方法发送它. </p>
<h2 id="服务的一些说明"><a href="#服务的一些说明" class="headerlink" title="服务的一些说明"></a>服务的一些说明</h2><p><strong>non-sticky服务</strong></p>
<p><code>IntentService</code>是一种<code>non-sticky</code>服务. <code>non-sticky</code>服务在完成所有已有任务时停止. 为获得<code>non-sticky</code>服务, 应返回<code>START_NOT_STICKY</code>或者<code>START_REDELIVER_INTENT</code>. </p>
<p>通过调用<code>stopSelf()</code>或<code>stopSelf(int)</code>方法, 我们告诉Android任务已经完成. <code>stopSelf()</code>是一个无条件方法. 不管<code>onStartCommand()</code>方法调用多少次, 该方法总是会成功停止服务.</p>
<p><code>IntentService</code>使用的是<code>stopSelf(int)</code>方法. 该方法需要来自<code>onStartCommand()</code>方法的启动ID. 只要在接收到最新的启动ID后, 该方法才会停止服务. </p>
<p>返回的<code>START_NOT_STICKY</code>和<code>START_REDELIVER_INTENT</code>的具体不同是, 如果系统需要在服务完成任务之前关闭它, 则服务的具体表现会有所不同. <code>START_NOT_STICKY</code>型服务会被关闭. 而<code>START_REDELIVER_INTENT</code>型服务, 则会在可用资源不再吃紧时, 尝试再次启动服务.  所以根据操作与应用的重要程度, 进行选择. <code>start_not_sticky</code>是<code>IntentService</code>的默认行为. 通过<code>setIntentRedelivery(true)</code>来切换模式. </p>
<p><strong>sticky服务</strong></p>
<p><code>sticky</code>服务会持续运行, 直到外部组件调用<code>Content.stopService(Intent)</code>方法让其停止为止. 为启动<code>sticky</code>服务, 应返回<code>START_STICKY</code>.</p>
<p><code>sticky</code>服务启动后会持续运行, 直到某个组件调用<code>Content.stopService(Intent)</code>方法为止. 如因某种原因需终止服务, 可传入一个null intent给<code>onStartCommand()</code>方法实现服务的重启. </p>
<p><code>sticky</code>服务适用于长时间运行的服务, 如音乐播放器这种启动后一直保持运行状态, 直到用户主动停止服务. </p>
<h2 id="broadcast-Intent"><a href="#broadcast-Intent" class="headerlink" title="broadcast Intent"></a>broadcast Intent</h2><p>Android设备中, 各种事件一直频繁的发生着. WIFI型号时有时无, 各种软件包获得安装, 电话的呼入呼出, 短信接收等. </p>
<p>许多的系统组件需要知道某些事件的发生. 为满足这样的需求, android提供了<code>broadcast intent</code>组件. </p>
<hr>
<p><strong>设备重启而重启的定时器</strong></p>
<p>设备重启后, 那些持续运行的应用通常也需要重启. 通过监听具有<code>BOOT_COMPLETED</code>操作的broadcast intent, 可得知设备是否已完成启动. </p>
<p>如果要实现这个功能, 首先定义一个广播, 继承<code>BroadcastReceiver</code>. 并在清单文件中声明<code>&lt;receiver&gt;</code>并添加intent过滤器设置一个<code>action</code>. 因为要监听系统开机所以需要添加一个使用权限<code>&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;&gt;</code></p>
<p>于<code>activity</code>和服务不同, 在配置文件中声明的<code>broadcast receiver</code>几乎总是需要声明<code>intent-filter</code>. <code>broadcast intent</code>就是为发送信息给多个监听者而生. 但显示的intent只有一个<code>receiver</code>. 因此显示的<code>broadcast intent</code>很少见. </p>
<hr>
<p><strong>如何使用receiver</strong></p>
<p><code>broadcast receiver</code>的存在很短暂, 因此它的作用也就受到限制, 例如无法使用任何异步API或登记任何的监听器, 因为<code>onReceiver()</code>回调一旦运行完, <code>receiver</code>也就不存在了. 而因为<code>onReceiver()</code>同样运行在主线程, 因此不可以执行耗时操作. </p>
<p>但是存在既有道理, 对于轻型任务代码的运行而言, <code>receiver</code>非常有用. 系统重启后, 定时运行的定时器也需要重置. 显示, 使用<code>broadcast receiver</code>处理这种小型任务再合适不过了(这里只是列举一个例子). </p>
<hr>
<p><strong>使用私有权限</strong></p>
<p>使用动态广播接收存在一个问题, 即系统中的任何应用均可监听并触发我们的<code>receiver</code>. 对于这种情况应该避免. 有两种方案可以选择. 如果<code>receiver</code>声明在<code>manifest</code>配置文件里, 且仅限应用内部使用, 则可在<code>receiver</code>标签上添加<code>android:exported=&quot;false&quot;</code>属性. 这样系统中的其他应用就再也无法接触到该<code>receiver</code>. 另外也可以创建自己的使用权限. 通过在清单文件中添加一个<code>&lt;permission&gt;</code>标签来完成. 例如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.suzeyu.android.TEST_PERMISSION&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:protectionLevel</span>=<span class="string">&quot;signature&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码使用了<code>protection level</code>签名, 定义了自己的定制权限. 权限本身只是一行字符串. 即使是自定义的权限, 也必须要在使用前获取它, 这是规则. </p>
<p>如果给定义的广播设置了权限, 那么在发送广播时(sendBroadcast), 和注册广播时. 和应用清单添加使用权限的声明. 3处需要注意. </p>
<hr>
<p><strong>深入了解protection level</strong></p>
<p>自定义权限必须指定<code>android:protectionLevel</code>属性值, Android根据<code>protectionLevel</code>属性值确定自定义权限的使用方式. 权限的所选值有四种. 对于仅限应用内部使用的权限, 通常会选择<code>signature</code>安全级别. </p>
<p>关于四种可选值的特征如下:</p>
<table>
<thead>
<tr>
<th>可选值</th>
<th>用法描述</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>用于阻止应用执行危险操作, 如访问个人隐私数据,联网传送数据等. 应用安装前, 用户可看到相应的安全级别, 但无需他们主动授权. <code>android.permission.RECEIVE_BOOT_COMPLETED</code>使用该安全级别. 同样, 手机振动也使用该安全级别. 虽然这些安全级别没有危险, 但最好让用户知晓可能带来的影响</td>
</tr>
<tr>
<td>dangerous</td>
<td>normal安全级别控制以外的任何危险操作, 如访问个人隐私数据, 通过网络接口收发数据, 使用可监视用户的硬件功能等. 总之, 包括一切可能为用户带来麻烦的行为. 网络使用权限, 相机使用权限以及联系人信息使用权限都属于危险操作. 需要<code>dangerous</code>权限级别时, Android会明确要求用户授权</td>
</tr>
<tr>
<td>signature</td>
<td>如果应用签署了于声明应用一致的权限证书, 则该权限由系统授予. 否则, 系统则作相应的拒绝. 权限授予时, 系统不会通知用户. 它通常适应于应用内部. 只要拥有证书, 则只有签署了同样证书的应用才能拥有该权限, 因此可自由控制权限的使用. 这里我们使用它阻止其他应用监听到应用发出的<code>broadcast</code>. 不过如有需要, 可定制开发能够监听他们的专有应用</td>
</tr>
<tr>
<td>signatureOrSystem</td>
<td>类似于<code>signature</code>授权界别. 但该授权级别针对Android系统镜像中的所有包权限. 该授权级别用于系统镜像内应用间的通信, 因此用户通常无需关心</td>
</tr>
</tbody></table>
<hr>
<p><strong>使用ordered broadcast接收结果</strong></p>
<p>常规的<code>Broadcast</code>可同时被其他应用所接收. 而如果希望他们按照某种顺序依次运行, 或知道他们什么时候全部结束运行是无法做到的. 所以为了解决这种情况, 可使用<strong>有序broadcast intent</strong>实现双向通信. 有序广播允许多个广播接收者依序处理<code>broadcast intent</code>. 另外 通过传入一个名为<code>result receiver</code>的特别<code>broadcast receiver</code>, 有序广播还可以实现让<strong>广播的发送者</strong>接收到<strong>广播接收者</strong>发送的返回结果.</p>
<p>通过<code>sendOrderedBroadcast(...)</code>发送有序广播. 和常规的广播相比有序广播的参数还多出五个. 一次为: 一个result receiver; 一个支持result receiver运行的Handler; 结果代码初始值; 结果数据; 有序broadcast的结果附加内容</p>
<p><code>result receiver</code>比较特殊, 只有在所有有序广播接收者结束运行后, 它才可以运行. </p>
<p>有序发送顺序是通过<code>receiver</code>的优先级作为依据. </p>
<p>关于优先级数值越高优先级越高. 如果要设置最后接收的接收者可以设定其优先级为**-999**(-1000及以下的值为系统保留值) </p>
<hr>
<p><strong>receiver长时运行任务</strong></p>
<p>如果不想受限于主线程的时间限制, 并希望<code>broadcast intent</code>可触发一个长时运行任务,有两种方式可以选择:</p>
<ul>
<li>将任务交给服务去处理, 然后再通过<code>broadcast receiver</code>启动服务. 服务可以运行很久, 直到完成需要处理的任务. 同时服务可将请求放在队列中, 然后依次进行处理, 或按其自认为合适的方式管理全部任务请求. </li>
<li>使用<code>BroadcastReceiver.goAsync()</code>方法. 该方法返回一个<code>BroadcastReceiver.PendingResult</code>对象, 随后, 可使用该对象提供结果. 因此, 可将<code>PendingResult</code>交给<code>AsyncTask</code>去执行长时运行任务, 然后再调用<code>PendingResult</code>的方法相应<code>broadcast</code></li>
</ul>
<p><code>goAsync()</code>方法两个弊端: 不支持旧设备; 其次它不够灵活: 仍需快速响应broadcast. </p>
<h2 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h2><p>首先在xml布局中添加<code>WebView</code>控件, 没什么好说的. 接下来. 开始代码设置. 应该先完成三件事情.</p>
<ul>
<li>指定<code>WebView</code>要打开的URL</li>
<li>启动<code>JavaScript</code>, <code>JavaScript</code>默认是禁用的. 最好启动以免不必要的错误. </li>
<li>覆盖<code>WebViewClient</code>类的<code>shouldOverrideUrlLoading(WebView, String)</code>方法. 并返回false.</li>
</ul>
<p>例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">   </span><br><span class="line">mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">   </span><br><span class="line">mWebView.loadUrl(要加载的网址);</span><br></pre></td></tr></table></figure>

<p>加载Url必须等到<code>WebView</code>配置完成之后. <code>WebSetting</code>是修改<code>WebView</code>配置的三种途径之一. 他还有一些其他可设置属性, 如用户代理字符串和显示文字大小. </p>
<p>配置<code>WebViewClient</code>. <code>WebViewClient</code>是一个事件接口, 通过提供自己实现的<code>WebViewClient</code>, 可响应各种渲染事件. 例如可检测渲染器何时开始从特定URL加载图片, 或决定是否需要向服务器重新提交POST请求.<br><code>WebViewClient</code>有多个方法可供覆盖, 其中大多数用不到. 然而必须覆盖其<code>shouldOverrideUrlLoading()</code>的默认方法. 当有新的URL加载到<code>WebView</code>时(如点击了某个链接),如果返回true那么有系统浏览器处理. 如果为false那么就是<code>webview</code>去加载. </p>
<p><strong>使用WebChromeClient优化WebView的显示</strong></p>
<p>如果说<code>WebViewClient</code>是响应渲染事件的接口, 那么<code>WebChromeClient</code>就是一个响应改变浏览器中装饰元素的事件接口, 包括<code>JavaScript</code>警告信息, 网页图标, 状态条架子啊,以及当前网页标题的刷新. </p>
<p>进度条和标题栏的更新都有各自的回调方法, 即<code>onProgressChange()</code>和<code>onReceivedTitle()</code> 方法. </p>
<hr>
<p><strong>处理WebView的设备旋转问题</strong></p>
<p>由于<code>WebView</code>包含了太多的数据, 以至无法再<code>onSaveInstanceState()</code>方法保存所有数据. 对于一些类似的类如<code>VideoView</code>. Android文档推荐让<code>activity</code>自己处理设备配置的变更. 也就是说, 不销毁重建. 那么就要让<code>activity</code>不会因设备配置变更而发生重建动作,而是自己去处理配置更改后的问题. 那么就需要在清单文件中声明属性.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;</span><br></pre></td></tr></table></figure>

<p>这个属性加在<code>activity</code>标签内部表明, 如果因键盘开关, 屏幕方向改变, 屏幕大小改变而发生的设配配置更改, 那么<code>activity</code>应自己处理配置更改, </p>
<h2 id="LocationManager"><a href="#LocationManager" class="headerlink" title="LocationManager"></a>LocationManager</h2><p>Android系统中的地理位置数据是由<code>LocationManager</code>系统服务提供的. 该系统服务向所有需要地理位置数据的应用提供数据更新. 更新数据的传送通常采用两种方式. </p>
<ul>
<li>使用<code>LocationListener</code>接口</li>
<li>使用<code>PendingIntent</code>获取地理位置更新</li>
</ul>
<p><code>LocationListener</code>接口可能是最直接的一种方式. 通过<code>onLocationChanged()</code>方法, 该接口提供的信息有:地理位置数据更新, 状态更新, 以及定位服务提供者启停状态的通知消息. 如只需将地理位置数据发送给应用中的单个组件, 使用<code>LocationListener</code>接口会很方便. 通过实现<code>LocationManager</code>类的<code>requestLocationUpdates()</code>或者<code>requestSingleUpdate()</code>方法即可. </p>
<p>使用<code>PendingIntent</code>来获取地理位置数据更新, 实际是要求<code>LocationManager</code>在将来某个时点帮忙发送某种类型的<code>Intent</code>. 这样即使应用组件甚至整个应用进程都销毁了, <code>LocationManager</code>仍会一直发送<code>intent</code>, 直到要求它停止并按需启动新组件响应他们. 利用这种优势, 即使持续进行设备定位, 也可以避免应用消耗过多资源. </p>
<p><code>LocationManager</code>是通过<code>Context.getSystemService(Context.LOCATION_SERVICE)</code>来获得的.<br>通过调用其<code>requestLocationUpdates(String, long, float, PendingIntent)</code>数值参数为: 最小等待时间(ms);  最短移动距离(m); </p>
<p>之后定义接收定位数据的广播接收者, 为了保证无论前台还是后台都可以接收更新数据, 最好使用清单文件进行注册. 在<code>onReceive()</code>实现方法中. <code>LocationManager</code>打包了附加额外信息的intent. <code>LocationManager.KEY_LOCATION_CHANGED</code>键值可指定一个表示最新更新的Location实例. 通过这个实例可以获取到服务提供者名字以及相应的经纬度数据. <strong>别忘了添加使用地理位置的权限</strong>. <code>&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;&gt;</code></p>
<p>也可以通过<code>LocationManag#getLastKnownLocation()</code>获取最近地理位置信息. 如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String provider = LocationManager.GPS_PROVIDER;</span><br><span class="line">Location lastKnown = mLocationManager.getLastKnownLocation(provider);</span><br></pre></td></tr></table></figure>

<h2 id="SQLite本地数据库"><a href="#SQLite本地数据库" class="headerlink" title="SQLite本地数据库"></a>SQLite本地数据库</h2><p>Android内置了操作SQLite的Java前端, 该前端的<code>SQLiteDatabase</code>类负责提供<code>Cursor</code>实例形式的结果集. </p>
<p>Android提供了一个帮助类, <code>SQLiteOpenHelper</code>类封装了一些存储应用数据的常用数据库操作, 如创建打开以及更新数据库等. </p>
<p>继承<code>SQLiteOpenHelper</code>通常要覆盖两个方法:</p>
<ul>
<li><code>onCreate()</code>: 为新建数据库创建表结构</li>
<li><code>onUpgrade()</code>: 可执行迁移代码, 实现不同版本间的数据库结构升级或转换. </li>
</ul>
<p>通常还需要实现一个父类的构造函数. 为父类提供必要的初始化参数, 数据库文件名, 可选<code>CursorFactory</code>参数的null值, 以及数据库版本号. </p>
<p><code>SQLiteOpenHelper</code>类有两个访问<code>SQLiteDatabase</code>实例的方法:</p>
<ul>
<li><code>getReadableDatabase()</code>   需要只读时使用</li>
<li><code>getWritableDatabase()</code>   需要可写数据库时使用</li>
</ul>
<p>这两种方法基本没有太大区别, 但在某种特定情况下, 如磁盘空间满了, 则可能无法获取可写数据库, 而只能获取到可读数据库. </p>
<p>查询<code>SQLiteDatabase</code>可返回描述结果的<code>Cursor</code>实例. <code>Cursor</code>将结果集看做是一系列的数据行和数据列, 但仅支持String以及原始数据类型的值 .(可使用CursorWrapper封装当前Cursor对象.下面说明)</p>
<hr>
<p><strong>使用CursorAdapter</strong></p>
<p><code>CursorAdapter</code>类的构造方法需要一个Context, 一个Cursor, 一个整型flag. 为了提倡使用<code>Loader</code>, 大多数flag已经被废弃或存在一些问题. 因此可直接传入0.</p>
<p>需要实现两个方法:</p>
<ul>
<li><code>newView(...)</code>: 会返回一个代表cursor中当前数据行的View. 在这里需要创建一个View并返回供item视图显示做准备</li>
<li><code>bindView(...)</code>: 进行绑定数据</li>
</ul>
<p><strong>关于查询数据操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  通过where子句. 限制查询只能返回一条记录, 然后封装到RunCursor中并返回</span></span><br><span class="line">Cursor wrapped = getReadableDatabase().query(TABLE_RUN,</span><br><span class="line">      <span class="keyword">null</span>,   <span class="comment">// All columns</span></span><br><span class="line">      COLUMN_RUN_ID + <span class="string">&quot; = ?&quot;</span>,           <span class="comment">// look for a run ID</span></span><br><span class="line">      <span class="keyword">new</span> String[]&#123;String.valueOf(id)&#125;, <span class="comment">// with the value</span></span><br><span class="line">      <span class="keyword">null</span>,   <span class="comment">// group by</span></span><br><span class="line">      <span class="keyword">null</span>,   <span class="comment">// having</span></span><br><span class="line">      <span class="keyword">null</span>,   <span class="comment">// order by</span></span><br><span class="line">      <span class="string">&quot;1&quot;</span>     <span class="comment">//  limit 1 row</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>就给一个简单的例子. 了解一下查询方法的参数. </p>
<h2 id="Loader加载异步数据"><a href="#Loader加载异步数据" class="headerlink" title="Loader加载异步数据"></a>Loader加载异步数据</h2><hr>
<p><strong>Loader于LoaderManager</strong></p>
<p><code>Loader</code>设计用于从数据源加载某类数据(如对象). 数据源可以是磁盘, 数据库, ContentProvider, 网络或者另一个进程. <code>loader</code>可在不阻塞主线程的情况下获取并发送结果数据给接收者. </p>
<p><code>loader</code>有三种内置类型: <code>Loader</code>, <code>AsyncTaskLoader</code>, <code>CursorLoader</code>. </p>
<ul>
<li>作为基类<code>Loader</code>本身没有多大用处. 它定义了供<code>LoaderManager</code>与其他<code>loader</code>通讯时使用的API.</li>
<li><code>AsyncTaskLoader</code>是一个抽象<code>Loader</code>. 它使用<code>AsyncTask</code>将数据加载任务转移到其他线程中处理. 几乎所有创建的有用的<code>loader</code>类都是<code>AsyncTaskLoader</code>的子类</li>
<li><code>CursorLoader</code>. 通过继承<code>AsyncTaskLoader</code>类, 它借助<code>ContentResolver</code>从<code>ContentProvider</code>加载<code>Cursor</code></li>
</ul>
<p><code>LoaderManager</code>管理着于loader间的所有通讯, 并负责启动, 停止和管理与组件关联的loader的生命周期方法. 在<code>activity</code>和<code>fragment</code>可通过<code>getLoaderManager()</code>方法返回一个实例并进行交互 </p>
<p>要初始化<code>Loader</code>可使用<code>initLoader(int, Bundler, LoaderCallbacks&lt;D&gt;)</code>方法. </p>
<p>参数说明如下:</p>
<ul>
<li>整数类型的loader标识符</li>
<li>Bundler参数(值可为空)</li>
<li>一个接口回调分别对应着创建, 完成, 重启的回调</li>
</ul>
<p>如果要强制重启现有的<code>loader</code>, 可使用<code>restartLoader()</code>方法. 在明确知道或怀疑数据比较陈旧时, 通常使用该方法重新加载最新数据. </p>
<p><strong>为什么使用loader而不直接使用AsyncTask</strong></p>
<p>有一个比较好的理由: 因设备旋转等原因发生配置更改时, LoaderManager可保证组件的loader及其数据不会丢失. </p>
<p>如果使用<code>AsyncTask</code>加载数据, 配置发生改变时, 就必须亲自管理其生命周期并保存它所取得的数据. 虽然可以通过<code>setRetainInstance(true)</code>解决了这些麻烦的问题, 但某些场景下, 还是要亲自编写代码处理才可以. </p>
<p><code>loader</code>的设计目的就是要解决部分这样烦恼的问题. 配置发生改变后. 我们初始化一个已经完成数据加载的<code>loader</code>, 他会立即发送取得的数据, 而不是尝试再次获取数据. 而且无论<code>fragment</code>是否已保留, 他都是如此工作. 这样一来就无需考虑<code>fragment</code>带来的生命周期问题. </p>
<p>实现步骤 = =不想写了….  就这样吧. </p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2016/09/20/《Android-编程实战》完善开发环境和优化/" data-toggle="tooltip" data-placement="top" title="《Android 编程实战》01-完善开发环境和优化">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2016/09/09/《Android编程权威指南》随记三-媒体与Intent等/" data-toggle="tooltip" data-placement="top" title="《Android编程权威指南》随记三 媒体与Intent等">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">文章目录</a>
                    </h5>
                    <ul class="catalog-body" style="padding-left: 0%; list-style:none;  width: 150%"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#android" title="android">android</a>
                        
                          <a class="tag" href="/tags/#笔记" title="笔记">笔记</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="#" target="_blank">Kaijun&#39;s Blog</a></li>
                    
                        <li><a href="#" target="_blank">Foo</a></li>
                    
                        <li><a href="#" target="_blank">Bar</a></li>
                    
                        <li><a href="#" target="_blank">Example Friends</a></li>
                    
                        <li><a href="#" target="_blank">It helps SEO</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "http-szysky-com";
    var disqus_identifier = "http://szysky.com/2016/09/10/%E3%80%8AAndroid%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/";
    var disqus_url = "http://szysky.com/2016/09/10/%E3%80%8AAndroid%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/szyskys">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/szysky">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/suzeyu1992">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://www.linkedin.com/in/szysky">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Szy&#39;sky Blog 2021
                    <br>
                    Theme by <a target="_blank" rel="noopener" href="http://huangxuan.me">Hux</a>
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span>
                    Ported by <a target="_blank" rel="noopener" href="http://blog.kaijun.rocks">Kaijun</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://szysky.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '5aca5df6308eba7bd10d5bac33225006';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>





<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>




<!-- Image to hack wechat -->
<img src="http://szysky.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
