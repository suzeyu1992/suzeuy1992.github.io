<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="suzeyu skyszy`blog">
    <meta name="keyword"  content="suzeyu skyszy`blog">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          《Android编程权威指南》随记三 媒体与Intent等 - 筑梦 suzeyu`苏泽钰
        
    </title>

    <link rel="canonical" href="http://szysky.com/2016/09/09/《Android编程权威指南》随记三-媒体与Intent等/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/hux-blog.min.css">


    <!-- Pygments Github CSS -->
    
<link rel="stylesheet" href="/css/syntax.css">


    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Szy&#39;sky Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">

                 


                      <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','uaGE1nqtyiBMes6-h6b9','2.0.0');
</script>

                    




                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://szysky.com/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
    .h1_nav{font-size: 13px; padding-left:0%; color: #ff0000;}
    .h2_nav{font-size: 12px;padding-left: 4%;color: #ff0000; }
    .h3_nav{font-size: 11px;padding-left: 12%;}
    .h4_nav{font-size: 10px;padding-left: 18%;}
    .h5_nav{font-size: 9px;padding-left: 24%;}
    .h6_nav{font-size: 8px;padding-left: 30%;}


</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#android" title="android">android</a>
                        
                          <a class="tag" href="/tags/#笔记" title="笔记">笔记</a>
                        
                    </div>
                    <h1>《Android编程权威指南》随记三 媒体与Intent等</h1>
                    <h2 class="subheading">抄书笔记</h2>
                    <span class="meta">
                        Posted by Suzeyu on
                        2016-09-09
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <blockquote>
<p>这本书属于入门, 有很多内容可以当做扩展来了解一些API, 并且有的时候可以适当的利用Google提供好的API来做一些高效开发节约时间成本. 原理东西本书偏少. 可以学习本书中的代码的编写风格, 书中代码都是采用<strong>MVC</strong>模型来编写的. 就写这么多, 下面开始整理一些小知识点.</p>
</blockquote>
<blockquote>
<p>关于Camera和SurfaceView的知识点练习都保存在仓库中的<strong>Criminal</strong>项目中.<br> <a target="_blank" rel="noopener" href="https://github.com/suzeyu1992/AndroidProgramminGuide">git地址</a></p>
</blockquote>
<h2 id="MediaPlay播放音频"><a href="#MediaPlay播放音频" class="headerlink" title="MediaPlay播放音频"></a>MediaPlay播放音频</h2><blockquote>
<p><code>MediaPlayer</code>是一个支持音频及视频文件播放的Android类. 可播放不同的来源(本地或网络流媒体).多种格式(WAV, MP3, MPEG-4, 3GPP等)的多媒体文件.</p>
</blockquote>
<p>直接贴出代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author :  suzeyu</span></span><br><span class="line"><span class="comment"> * Time   :  2016-09-07  上午10:17</span></span><br><span class="line"><span class="comment"> * Blog   :  http://szysky.com</span></span><br><span class="line"><span class="comment"> * GitHub :  https://github.com/suzeyu1992</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ClassDescription : 主要用来管理MediaPlayer的实例, 和对该实例的播放和停止等功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MediaPlayer mPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mPlayer != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 销毁, 否则MediaPlayer将一直占用着音频解码硬件及其他系统资源</span></span><br><span class="line">            mPlayer.release();</span><br><span class="line">            mPlayer = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 防止过多的创建MediaPlayer实例, 第一步先销毁已经存在的</span></span><br><span class="line">        stop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  设置要播放的音频文件, 如果音频来自其他渠道如网络或者URI, 则使用其他的create(...)函数</span></span><br><span class="line">        mPlayer = MediaPlayer.create(context, R.raw.ss_small);</span><br><span class="line">        mPlayer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止过多的创建MediaPlayer实例, 第二步设置监听, 存活时间为音频的时长</span></span><br><span class="line">        mPlayer.setOnCompletionListener(<span class="keyword">new</span> MediaPlayer.OnCompletionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(MediaPlayer mp)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 音频播放完成</span></span><br><span class="line">                stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得在<code>res/raw/</code>放置要播放的文件. 一个简便的播放就是这样.详细的查看官网的对于<code>MediaPlayer</code>的介绍</p>
<h2 id="播放视频"><a href="#播放视频" class="headerlink" title="播放视频"></a>播放视频</h2><p>关于播放视频, <code>Android</code>提供了多种实现方式. 其一便是使用上面说到的<code>MediaPlayer</code>, 而我们需要做的只是设置在哪里播放即可. </p>
<p>在<code>Android</code>系统中, 快速刷新显示的可视图像(如视频)是在<code>SurfaceView</code>中显示的. 准确的说, 是在<code>SurfaceView</code>内嵌的<code>Surface</code>中显示的. 通过获取<code>SurfaceView的SurfaceHolder</code>可是实现在<code>Surface</code>上显示视频. 简单的说就是通过<code>MediaPlayer.setDisplay(SurfaceHolder)</code>方法, 将<code>MediaPlayer</code>类于<code>SurfaceHolder</code>关联起来即可.</p>
<p>通常来说直接使用<code>VideoView</code>实例来播放视频会更简单些, 不同于<code>SurfaceView于MediaPlayer</code>之间的交互, <code>VideoView是与MediaController</code>交互的, 这样可以方便地提供视频播放界面.  而<code>VideoView</code>是不接受<em>ID资源的</em>. 而只接受文件路径或者URI对象. </p>
<p>创建一个指向<strong>Android资源</strong>的URI, 可使用如下代码:</p>
<p><code>Uri resourceUri = Uri.parse(&quot;android.resource://包名/raw/文件名称&quot;);</code></p>
<p>使用了<code>android.resource</code>格式, 用包名作为主机名, 资源文件类型与文件名称组成了一个路径用以创建URI.完成后就可以将其传给<code>VideoView</code>使用.</p>
<h2 id="Camera与SurfaceView"><a href="#Camera与SurfaceView" class="headerlink" title="Camera与SurfaceView"></a>Camera与SurfaceView</h2><ul>
<li><code>Camera: </code>提供了对设备相机硬件级别的调用. 相机是一种<strong>独占性资源</strong>: 一次只能有一个activity调用(如果你的应用没有释放相机资源,那么系统的相机也就无法调起使用)</li>
<li><code>SurfaceView: </code>这是一种特殊的视图, 可直接将要显示的内容渲染输出到设备的屏幕上. </li>
</ul>
<p>首先既然使用了相机那么就需要添加相机的使用权限 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--增加相机使用权限--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CAMERA&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定应用使用的某项特色功能, 这个属性可以保证那些配备相机功能的设备才能看到发布在GooglePlay上的此应用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.camera&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>uses-feature</code>对我们貌似没什么用处. </p>
<p>既然是拍照那么很多都是横屏的,所以清单文件中把所在的<code>&lt;activity&gt;</code>设置横屏模式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.activity.CrimeCameraActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:screenOrientation</span>=<span class="string">&quot;landscape&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>开始了解相机使用</strong></p>
<ul>
<li><code>public static Camera open(int)</code></li>
<li><code>public static Camera release()</code></li>
</ul>
<p>这两个方法是管理<code>Camera</code>的方法. 最好用户可以与界面进行交互分别调用. 如<code>onResume()</code>和<code>onPause()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onResume();</span><br><span class="line">  <span class="comment">// 0为打开后置摄像头, 如果没有后置摄像头那么就打开前置摄像头</span></span><br><span class="line">  mCamera = Camera.open(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onPause();</span><br><span class="line">  <span class="keyword">if</span>(mCamera != <span class="keyword">null</span>)&#123;</span><br><span class="line">      mCamera.release();</span><br><span class="line">      mCamera = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>相机打开了现在轮到Surface,因为Camera的拍照需要它</strong></p>
<p><code>SurfaceView</code>类实现了<code>SurfaceHolder</code>接口.  首先我们先获取<code>SurfaceHolder</code>实例.(在<code>Activity#onCreate</code>或者<code>Fragment#onCreateView()</code>只要能保证布局已经加载就可以)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  对SurfaceView控件进行一些初始化和绑定客户端Camera</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSurfaceView</span><span class="params">(View rootView)</span> </span>&#123;</span><br><span class="line">   mV_sfv_camera = (SurfaceView) rootView.findViewById(R.id.sfv_camera_display);</span><br><span class="line">   SurfaceHolder holder = mV_sfv_camera.getHolder();</span><br><span class="line">   <span class="comment">// setType设置只为兼容旧版本3.0之前,可以选择考虑是否需要</span></span><br><span class="line">   holder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//  对SurfaceView的声明周期进行关联</span></span><br><span class="line">   holder.addCallback(<span class="keyword">new</span> SurfaceHolder.Callback() &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** SurfaceView的视图层级结构被放在屏幕上时候被调用, 这里也是SurfaceView与客户端(Camera)进行关联的地方*/</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (mCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   mCamera.setPreviewDisplay(holder);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               Log.e(TAG, <span class="string">&quot;@@-&gt; Camera设置关联SurfaceView预览显示失败!&quot;</span> );</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**  Surface首次显示在屏幕上的时候被动调用的方法, 通过此参数可以知道Surface的像素格式以及他的宽高.</span></span><br><span class="line"><span class="comment">        通过此方法可以通知Surface客户端, 有多大的绘制区域可以使用. */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (mCamera == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">           <span class="comment">// The surface has change size, update the camera preview size</span></span><br><span class="line">           Camera.Parameters parameters = mCamera.getParameters();</span><br><span class="line">           Camera.Size size = getSupportedSize(parameters.getSupportedPreviewSizes(), width, height);</span><br><span class="line">           <span class="comment">//  设置图片尺寸大小</span></span><br><span class="line">           parameters.setPictureSize(size.width, size.height);</span><br><span class="line"></span><br><span class="line">           mCamera.setParameters(parameters);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//  开始在Surface上绘制</span></span><br><span class="line">               mCamera.startPreview();</span><br><span class="line">           &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">               <span class="comment">//  如果开始预览绘制失败那么我们通过这里来释放相机资源</span></span><br><span class="line">               Log.e(TAG, <span class="string">&quot;@@-&gt; startPreview()启动失败, 准备释放相机资源!&quot;</span> );</span><br><span class="line">               mCamera.release();</span><br><span class="line">               mCamera = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** SurfaceView从屏幕上移除时, Surface也随之被销毁, 通过客户端停止使用Surface*/</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (mCamera != <span class="keyword">null</span>)&#123;</span><br><span class="line">               mCamera.stopPreview();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  找出具有最大数目的像素的尺寸</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Camera.<span class="function">Size <span class="title">getSupportedSize</span><span class="params">(List&lt;Camera.Size&gt; sizes, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">   Camera.Size bestSize = sizes.get(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">int</span> largestArea = bestSize.width * bestSize.height;</span><br><span class="line">   <span class="keyword">for</span> (Camera.Size s : sizes) &#123;</span><br><span class="line">       <span class="keyword">int</span> area = s.width * s.height;</span><br><span class="line">       <span class="keyword">if</span> (area &gt; largestArea)&#123;</span><br><span class="line">           bestSize = s;</span><br><span class="line">           largestArea = area;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> bestSize;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>SurfaceHolder</code>是我们与<code>Surface</code>对象联系的纽带. <code>Surface</code>对象代表着原始像素数据的缓冲区. </p>
<p><code>Surface</code>对象也有生命周期: <code>SurfaceView</code>出现在屏幕上时, 会创建<code>Surface</code>; <code>SurfaceView</code>从屏幕上消失的时候,<code>Surface</code>随即被销毁. <code>Surface</code>不存在的时候, 必须保证没有任何内容要在它上面绘制.</p>
<p>不像其他视图一样, <code>SurfaceView</code>及其协同工作对象都不会自我绘制内容. 对于任何想要将内容绘制到<code>Surface</code>缓冲区的对象, 我们都称其为<code>Surface</code>的客户端. 比如这里的<code>Camera</code></p>
<p>为了对应<code>Surface</code>各个生命周期, <code>SurfaceHolder</code>提供了另外一个接口<code>SurfaceHolder.Callback</code>来关联.</p>
<p><strong>确定预览界面的大小</strong></p>
<p>可能看到了<code>surfaceChanged()</code>的生命周期回调中设置了<code>Camera</code>实例的一个属性大小. </p>
<p>首先要知道<strong>相机的预览大小不能随意设置</strong>, 如果设置了不可接受的值有可能会出现崩溃. 所以我们应该先获取到设备相机所支持的预览尺寸大小. 通过<code>Camera.Parameters</code>类中的<code>getSupportedPreviewSizes()</code>就可以获取到<strong>相机的支持的预览尺寸列表</strong>. </p>
<p>这个方法返回的是一个<code>List&lt;Camera.Size&gt;</code>, 泛型<code>Camera.Size</code>每一个实例都封装了一个具体的图片宽高尺寸. 利用<code>getSupportedSize()</code>简便的比较方法可以达到选择一个最大的像素尺寸. </p>
<p><strong>有可能你会需要先检测设备是否有前后相机</strong></p>
<p>可以获取到<code>PackageManager</code>后, 调用<code>hasSystemFeature(String)</code>方法并传入表示设备特色功能的常量即可根据布尔值来判断. <code>FEATURE_CAMERA</code>常量代表后置相机, <code>FEATURE_CAMERA_FRONT</code>常量代表前置相机. </p>
<p><strong>目前为止相机开启并渲染值Surface应该没问题了,下面就是利用Camera进行照片</strong></p>
<p>主要逻辑就是从相机的实时预览中捕获一帧图像, 然后将其保存为JPEG格式的文件. 而要进行拍摄需要<code>Camera#takePicture(Camera.shutterCallback shutter, Camera.PictureCallback raw, Camera.PictureCallback jpeg)</code></p>
<ul>
<li><code>shutterCallback</code> 此回调里面的方法会在相机捕获图像的时候调用, 但此时图像数据还未处理完成.</li>
<li><code>第一个PictureCallback</code>  回调方法是在原始图像数据可用时调用, 通常来说, 是在加工处理原始图像数据且没有存储之前.</li>
<li><code>第二个PictureCallback</code>  回调方法是在JPEG版本的图像可用时候调用. </li>
</ul>
<p>如果不需要某一个步骤的回调可以直接传递null. 这里我们实现参数一和参数三的回调, 首先定义回调如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  在进行快门的时候进行进度条View的显示</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Camera.ShutterCallback mShutterCallback = <span class="keyword">new</span> Camera.ShutterCallback() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//  这里我做了照相开始时候显示进度条, 如果为了练习这里可以不需要</span></span><br><span class="line">       mVFlProgress.setVisibility(View.VISIBLE);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  Camera如果快门之后有数据处理生成成功,  那么会调此回调, 可以进行把数据写入到本地的动作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Camera.PictureCallback mJpegCallback = <span class="keyword">new</span> Camera.PictureCallback() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPictureTaken</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// create a filename</span></span><br><span class="line">       String filename = UUID.randomUUID().toString()+<span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">       <span class="comment">//  save the jpeg date to disk</span></span><br><span class="line">       FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 获得输出流进行数据的写入</span></span><br><span class="line">           out = mContext.openFileOutput(filename, Context.MODE_PRIVATE);</span><br><span class="line">           out.write(data);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           Log.e(TAG, <span class="string">&quot;onPictureTaken: @@-&gt; 图片写入disk失败, 失败文件地址:&quot;</span>+filename, e );</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 进行清扫动作, 关流</span></span><br><span class="line">           <span class="keyword">if</span> (out != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   out.close();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   Log.e(TAG, <span class="string">&quot;onPictureTaken: @@-&gt; 流文件关流失败, 失败文件地址:&quot;</span>+filename, e );</span><br><span class="line">                  </span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      Log.i(TAG, <span class="string">&quot;onPictureTaken(): 照片 JPEG 保存成功, 即将关闭activity, 保存地址:&quot;</span>+filename);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>回调定义好了之后, 剩下的只需要搞一个按钮, 添加点击事件通过调用<code>Camera</code>的实例的<code>takePicture()</code>传入自定义的回调方法即可. </p>
<p><strong>扩展:</strong></p>
<p>如果需要显示大图可以直接<code>DialogFragment</code>. </p>
<ol>
<li>首先设置<code>Fragment</code>的样式为<code>DialogFragment.STYLE_NO_TITLE</code>.</li>
<li>因为想要的效果为一个图片查看放大, 那么不需要显示<code>AlertDialog</code>视图自带的标题和按钮. 所以可以直接复写<code>onCreateView()</code>方法使用一个简单视图, 比覆盖<code>onCreateDialog()</code>方法使用<code>Dialog</code>更简单.快捷灵活.</li>
<li>通过文件的路径得到<code>Bitmap</code>设置到在<code>onCreateView()</code>中创建并返回的<code>ImageView</code>即可.</li>
</ol>
<h2 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h2><p>在<code>Android</code>系统中, 使用<strong>隐式Intent</strong>可以启动其他应用的activity. 在<strong>显示Intent</strong>中, 需要指定要启动的<code>activity</code>类. 操作系统会负责启动它. 而<strong>隐式Intent</strong>中, 只要描述清楚要完成的任务, 操作系统会找到合适的应用. 并在其中启动相应的<code>activity</code>.</p>
<p><strong>典型的隐式Intent的组成</strong></p>
<ul>
<li><strong>要执行的动作(action)</strong>: 通常以<code>Intent</code>类中的常量进行表示. 例如要访问查看某个<code>URL</code>,可以使用<code>Intent_ACTION_VIEW</code>; 要发送邮件,可以使用<code>Intent.ACTION_SEND</code></li>
<li><strong>要发送的数据位置以及数据类型</strong>: 数据位置的话可能会是某个网页的<code>URL</code>,也可能是指向某个文件的<code>URI</code>, 或者指向<code>ContentProvider</code>中某条记录的某个内容<code>URI</code>; 数据类型这里指的是<code>MIME</code>形式的数据类型, 如<code>text/html</code>或者<code>audio/mpeg3</code>. 如果一个intent包含某类数据的位置, 那么通常可以从中推测出数据的类型. </li>
<li><strong>可选类别(category)</strong>:   如果<code>action</code>用于描述具体要做什么, 那么类别通常用来描述我们<strong>何时,何地或者说如何使用</strong>某个activity. <code>android.intent.category.LAUNCHER</code>类别表明, activity应该显示在顶级应用启动器中. 而<code>android.intent.category.INFO</code>类别表明,虽然activity向用户显示了包信息, 但它不应该显示在启动器中. </li>
</ul>
<p><strong>而在配置清单文件中的intent过滤器设置时</strong></p>
<ul>
<li><code>&lt;action&gt;</code>: 告诉操作系统, activity能够处理指定的哪个action动作.</li>
<li><code>&lt;category&gt;</code>: 一般情况下都是要指定<code>DEFAULT</code>类别. 每发起<strong>隐式intent</strong>如果没有指定<code>category那么系统都会默认的添加</code>DEFALUT`类别. </li>
</ul>
<p>操作系统进行<code>隐式Intent</code>寻找的时候, 是不需要使用数据(extra)来参与匹配规则的. </p>
<p><strong>利用Intent选择器</strong></p>
<p>比如打开一个视频文件的时候, 如果手机上有多个选择的话可能会弹出一个全部列表, 然后选择一个进行播放, 而之后会发现再也不会询问用户使用哪个视频播放软件进行播放. 对于这种情况有时候或许不需要, 这个时候就可以使用<strong>选择器</strong>来创建一个activity来展示可打开的软件, 每次都进行选择. 使用很简单. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">intent.putExtra(Intent.EXTRA_TEXT, getCrimeReport());</span><br><span class="line">intent.putExtra(Intent.EXTRA_SUBJECT, getString(R.string.crime_report_subject));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个选择每一次都显示activity的选择器. </span></span><br><span class="line"><span class="comment">// 这是重点</span></span><br><span class="line">intent= intent.createChooser(intent, getString(R.string.send_report));</span><br><span class="line"></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>通过<code>createChooser()</code>方法重新构建一个<code>intent</code>即可, 参数二传递的字符串是用来作为弹出的选择界面的标题.</p>
<p><strong>再说一下获取联系人信息</strong></p>
<p>如果要获取手机通讯录, 那么要指定<code>action</code>,并且要找指定获取位置; action对应的<code>Intent.ACTION_PICK</code>. 获取的位置为<code>ContactsContract.Contacts.CONTENT_URI</code>. 就是请求Android协助从手机联系人数据库获取某个具体联系人. </p>
<p>打开手机联系人代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开联系人Contract列表</span></span><br><span class="line"><span class="comment">// 这是通讯录应用将其权限临时给了本应用, 首先通讯录应用对联系人的数据库具有全部权限. 所以在通讯录应用</span></span><br><span class="line"><span class="comment">// 返回包含在Intent中的URI的时候, 他会添加一个Intent.FLAG_GRANT_READ_URI_PERMISSION标识,</span></span><br><span class="line"><span class="comment">// 此标志向系统表示, 我们这个应用可以使用联系人数据一次.</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测是否有接收此Intent的应用</span></span><br><span class="line">List&lt;ResolveInfo&gt; resolveInfos = getActivity().getPackageManager().queryIntentActivities(intent, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resolveInfos.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">startActivityForResult(intent, REQUEST_CONTACT);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Toast.makeText(getActivity().getApplicationContext(), <span class="string">&quot;无法打开Intent&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码很容易懂, 并且做了一定的防错处理.  接下来就准备接收返回结果就可以在<code>onActivityResult()</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (requestCode == REQUEST_CONTACT)&#123;</span><br><span class="line">  <span class="comment">//  打开联系人列表关闭后返回的逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  从intent取出URI, 该数据URI是一个指向用户所选联系人的定位符.</span></span><br><span class="line">  Uri contactUri = data.getData();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  specify which fields you want you query to return values for</span></span><br><span class="line">  <span class="comment">//  指定在返回数据的时候所对应查找的字段</span></span><br><span class="line">  String[] queryFileds = &#123;ContactsContract.Contacts.DISPLAY_NAME&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  perform query</span></span><br><span class="line">  Cursor query = getActivity().getContentResolver().query(contactUri, queryFileds, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (query.getCount() == <span class="number">0</span>)&#123;</span><br><span class="line">      query.close();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取嫌疑人的姓名 添加到陋习记录中的suspect</span></span><br><span class="line">  query.moveToFirst();</span><br><span class="line">  String suspect = query.getString(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拿到了姓名 可以做后续的事情....</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面获得了一个<code>Cursor</code>, 因为已经知道<code>Cursor</code>只是包含一条记录, 所以将<code>Cursor</code>移动到第一条记录并获取它的字符串形式.就是姓名. </p>
<p>上面代码中有两句话是对可以响应的<code>activity</code>做检查. 通过<code>PackageManager#queryIntentActivitys()</code>返回集合的size大小来决定是否可以执行后续的操作.</p>
<p><strong>打电话的隐式Intent</strong></p>
<p>电话相关的<code>Intent</code>有两种</p>
<ul>
<li><code>Intent.ACTION_DIAL</code>: 选择联系人(得到号码发送一个<code>tel:xxx</code>数据uri)之后会停止到拨号界面等待用户手动呼叫</li>
<li><code>Intent.ACTION_CALL</code>: 选择联系人(得到号码发送一个<code>tel:xxx</code>数据uri)之后会立即拨打出去. 而不会等待用户的手动拨打.</li>
</ul>
<h2 id="深入了解Intent"><a href="#深入了解Intent" class="headerlink" title="深入了解Intent"></a>深入了解Intent</h2><p>利用<code>隐式的Intent</code>可以创建一个启动器来替换系统默认的启动器应用. 例如这样:</p>
<p><img src="Launch.png"></p>
<p>展示出来手机上面的所有应用, 选择一个并可以打开, 有点丑, 你也可以设置上图片.  显示实现这个直接贴出代码.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  创建一个隐式Intent, 从PackageManager中获取匹配intent的activity列表</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_MAIN);</span><br><span class="line">intent.addCategory(Intent.CATEGORY_LAUNCHER);</span><br><span class="line"></span><br><span class="line">PackageManager pm = getActivity().getPackageManager();</span><br><span class="line">List&lt;ResolveInfo&gt; resolveInfos = pm.queryIntentActivities(intent, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Log.i(TAG, <span class="string">&quot;onCreate: 可以打开的数量:&quot;</span>+resolveInfos.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//  进行排序</span></span><br><span class="line">Collections.sort(resolveInfos, <span class="keyword">new</span> Comparator&lt;ResolveInfo&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ResolveInfo o1, ResolveInfo o2)</span> </span>&#123;</span><br><span class="line">      PackageManager pm = getActivity().getPackageManager();</span><br><span class="line">      <span class="comment">//  按照名称进行排序</span></span><br><span class="line">      <span class="keyword">int</span> result = String.CASE_INSENSITIVE_ORDER.compare(o1.loadLabel(pm).toString(), o2.loadLabel(pm).toString());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>首先利用<code>PackageManager</code>对<code>Main/Launcher</code>进行匹配, 这个没什么说的, 所有的应用都有一个启动入口就是这个. 可以得到所有应用的入口信息集合. </p>
<p>这里有一点需要了解: <strong><code>MAIN/LAUNCHER</code>intent过滤器不能<code>startActivity()</code>这种方式发送的<code>MAIN/LAUNCHER</code>相匹配</strong>.  因为对于<code>类别category为Launcher</code>的时候, 系统是不希望你通过隐式Intent的方式去打开. 而是要你使用显示intent. 一般情况下隐式Intent打开的时候系统总是会给你添加<code>category为default</code>的类别. 所以可以认为<code>隐式Intent</code>打开的基本都是过滤器信息中类别包含为<code>Default</code>的类别的Intent. 而这一点在系统的入口<code>activity</code>过滤其中却无法得到保证. </p>
<p>定义了<code>MAIN/LAUNCHER</code>过滤器的activity是应用的主要入口, 它只关心作为应用主要入口点要处理的工作. 通常不关心自己是否属于默认的主要入口点, 因此,他也就不必包含<code>CATEGORY_DEFAULT</code>类别. </p>
<p><strong>但好在我们可以通过隐式的<code>MAIN/LAUNCHER</code><strong>查到匹配的<code>activity</code>集合信息, 而不需要先打开. 通过集合中的每个activity的<code>ResolveInfo</code>实例得到<code>ActivityInfo</code>我们也就可以得到</strong>包名, 类名</strong>. 那么就可以通过<strong>显示Intent打开</strong>! 如下代码</p>
<p>通过上面得到的集合, 随便获取一个<code>resolveInof</code>实例.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResolveInfo resolveInfo = (ResolveInfo) resolveInfos.get(<span class="number">0</span>);;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  准备获取要打开activity的包名 类名等信息</span></span><br><span class="line">ActivityInfo activityInfo = resolveInfo.activityInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (activityInfo == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建显示Intent来打开Activity</span></span><br><span class="line"><span class="comment">//  先指定一个action</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_MAIN);</span><br><span class="line">intent.setClassName(activityInfo.applicationInfo.packageName, activityInfo.name);</span><br><span class="line"><span class="comment">//  添加新任务标识给intent</span></span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line"></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>上面使用的是<code>setClassName()</code>方法, 这个方法可以自动创建<strong>组件名</strong>, 也可以自己通过类名和包名创建一个<strong>ComponentName</strong>, 然后使用<code>setComponent()</code>创建一个显示的intent. </p>
<p>上面还添加了一个<code>FLAG</code>, 主要的区别就是没有这个<code>Flag</code>的话, 那么打开的新应用的界面本质上是存在我们的<strong>应用任务栈中</strong>, 如果有那么就会在<strong>属于自己独立的任务中</strong>. 如下图, 在我们自己的应用打开同一个任务. 然后查看任务管理器. (前面为没有添加flag的)</p>
<p><img src="taskStack.png"></p>
<p>至此, 现在这个应用可以得到手机的全部应用并可以做为展示列表.  但是还没完, 还差一点<strong>将我们这个应用作为设备主屏幕</strong>. </p>
<p>没有人愿意通过一个应用来启动另一个应用, 所以要做的就是替换<code>Android主界面</code>配置我们应用的启动<code>activity</code>再添加两个类别category,</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.NerdLauncherActivity&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.HOME&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="应用图标与任务重排"><a href="#应用图标与任务重排" class="headerlink" title="应用图标与任务重排"></a>应用图标与任务重排</h2><p>通过上面的获得的<code>ResolveInfo.loadLable()</code>方法, 可以获取各个<code>activity</code>的名称, 其中还有一个方法<code>loadIcon()</code>可以使用该方法为每一个应用加载显示图标. </p>
<p>关于<strong>任务重排</strong>, 需要使用<code>ActivityManager</code>系统服务, 该系统服务提供了当前运行<code>activity</code>, 任务以及应用的有用信息.  通过<code>Activity.getSystemService(Activity.ACTIVITY_SERVICE)</code>来获取<code>ActivityManager</code>然后调用<code>ActivityManager实例的getRunningTasks()</code>方法, 得到按照时间由近到久的排序的任务列表. 在调用<code>moveTaskToFront()</code>方法实现将任意任务切换到前台. 关于任务切换需要一些权限配置, 具体参考android文档.</p>
<h2 id="进程和任务"><a href="#进程和任务" class="headerlink" title="进程和任务"></a>进程和任务</h2><ul>
<li>进程: 是操作系统创建的供应用对象生存以及应用运行的地方. 包含了应用的全部运行代码和对象.</li>
<li>每一个<code>activity</code>实例都仅存在一个进程和一个任务中. 这也是进程与任务的唯一类似的地方. </li>
<li>任务: 只包含<code>activity</code>, 这些<code>activity</code>通常来自不同应用. </li>
</ul>
<p><code>activity</code>赖以生存的任务和进程有可能会有所不同. 比如上面的<code>深入了解Intentn</code>中给出的图片参考. 可以发现. 当我没有指定<code>new_task</code>的时候, 新的应用打开的activity是和我们的应用在一个任务栈的. 这也就意味当后退的时候虽然看着只是界面的切换,但是实际上发生了<code>进程间的切换</code></p>
<h2 id="XmlPullParser使用"><a href="#XmlPullParser使用" class="headerlink" title="XmlPullParser使用"></a>XmlPullParser使用</h2><p><code>XmlPullParser</code>接口采用拉的方式从<code>xml</code>数据流中获取解析事件. Android内部也使用<code>XmlPullParser</code>接口来实例化布局文件. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟一个xml字符串</span></span><br><span class="line">String textXMLStr = <span class="string">&quot;&lt;school&gt;\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;    &lt;class name=\&quot;1年级\&quot;&gt;\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;        &lt;student name=\&quot;张三\&quot;/&gt;\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;        &lt;student name=\&quot;李四\&quot;/&gt;\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;    &lt;/class&gt;\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;    &lt;class name=\&quot;2年级\&quot;&gt;\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;        优班\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;        &lt;student name=\&quot;张三\&quot;/&gt;\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;        &lt;student name=\&quot;李四\&quot;/&gt;\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;    &lt;/class&gt;\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;&lt;/school&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用xmlPullParser的工厂类创建出一个解析流对象</span></span><br><span class="line">XmlPullParser xmlPullParser = XmlPullParserFactory.newInstance().newPullParser();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把要解析的xml格式的字符串设置到解析流对象中</span></span><br><span class="line">xmlPullParser.setInput(<span class="keyword">new</span> StringReader(textXMLStr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备开始解析 移动指针到第一个标签</span></span><br><span class="line"><span class="keyword">int</span> eventType = xmlPullParser.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果标签类型不是结束文档标签标示, 那么就标示还有内容继续循环</span></span><br><span class="line"><span class="keyword">while</span>(eventType != XmlPullParser.END_DOCUMENT)&#123;</span><br><span class="line"> <span class="comment">// 判断class标签</span></span><br><span class="line"> <span class="keyword">if</span> (eventType == xmlPullParser.START_TAG &amp;&amp; <span class="string">&quot;class&quot;</span>.equals(xmlPullParser.getName()))&#123;</span><br><span class="line">     String className = xmlPullParser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">     Log.e(<span class="string">&quot;sususu&quot;</span>,<span class="string">&quot;获得的class标签的名称属性为: &quot;</span>+className );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 判断student标签</span></span><br><span class="line"> <span class="keyword">if</span> (eventType == xmlPullParser.START_TAG &amp;&amp; <span class="string">&quot;student&quot;</span>.equals(xmlPullParser.getName()))&#123;</span><br><span class="line">     String studentName = xmlPullParser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">     Log.e(<span class="string">&quot;sususu&quot;</span>,<span class="string">&quot;获得的student标签的属性: &quot;</span>+studentName );</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 移动指针到下一个标签</span></span><br><span class="line"> eventType = xmlPullParser.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img src="xmlPullParser.png"></p>
<p>代码中的注释已经很详细了, 不用再做解释. 有一点需要注意, 如果要获得便签的内容的话,那么别忘了考虑到空白字符或者换行符的也是存在的. </p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2016/09/10/《Android编程权威指南》随记四-组件等/" data-toggle="tooltip" data-placement="top" title="《Android编程权威指南》随记四 组件等">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2016/09/08/《Android编程权威指南》随记二-Fragment的概括/" data-toggle="tooltip" data-placement="top" title="《Android编程权威指南》随记二 Fragment的概括">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">文章目录</a>
                    </h5>
                    <ul class="catalog-body" style="padding-left: 0%; list-style:none;  width: 150%"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#android" title="android">android</a>
                        
                          <a class="tag" href="/tags/#笔记" title="笔记">笔记</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="#" target="_blank">Kaijun&#39;s Blog</a></li>
                    
                        <li><a href="#" target="_blank">Foo</a></li>
                    
                        <li><a href="#" target="_blank">Bar</a></li>
                    
                        <li><a href="#" target="_blank">Example Friends</a></li>
                    
                        <li><a href="#" target="_blank">It helps SEO</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "http-szysky-com";
    var disqus_identifier = "http://szysky.com/2016/09/09/%E3%80%8AAndroid%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8EIntent%E7%AD%89/";
    var disqus_url = "http://szysky.com/2016/09/09/%E3%80%8AAndroid%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8EIntent%E7%AD%89/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/szyskys">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/szysky">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/suzeyu1992">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://www.linkedin.com/in/szysky">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Szy&#39;sky Blog 2021
                    <br>
                    Theme by <a target="_blank" rel="noopener" href="http://huangxuan.me">Hux</a>
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span>
                    Ported by <a target="_blank" rel="noopener" href="http://blog.kaijun.rocks">Kaijun</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://szysky.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '5aca5df6308eba7bd10d5bac33225006';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>





<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>




<!-- Image to hack wechat -->
<img src="http://szysky.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
